# 3/8第03课：Linux 的启动流程

一直在构思怎么安排课程顺序才能让读者由浅入深一层一层的去理解内核。在上一篇讲了内核的设备树知识点，设备树的出现是为了解决设备和驱动耦合性的问题，本节的重点自然是讲解设备和驱动的启动流程，设备和驱动的流程是整个内核启动的核心，也是工作中最常面对的问题。出于知识点的系统性考虑，在进入主题之前我们先看下整个 Linux 在 ARM 中的启动流程如何。

#### Uboot 的启动流程

ARM Linux 的启动流程大致为：Uboot → Kernel → Root filesystem。Uboot 在上电的时候就拿到 CPU 的控制权，实现了硬件的初始化。具体是怎么实现的呢？一起来看一下，CPU 的内部集成了小容量的 Sram，而 PC 指针一上电就指向 Sram 的起始地址 0x00000000，所以一上电 Uboot 代码就得到了运行。

Uboot 拿到 CPU 使用权就开始做初始化工作，比如关闭看门狗、设置 CPU 运行模式、设置堆栈、初始化内存、网卡、nand flash 等，最后把 Linux 内核加载到内存中。

- 初始化 RAM

因为内核要在 RAM 中运行，所以在调用内核之前必须初始化和设置 RAM，为调用内核做好准备。

- 初始化串口

内核在启动过程中可以将信息通过串口输出，这样就可以清楚的知道内核启动信息。虽然串口不是 Uboot 必须要完成的工作，但是通过串口可以方便调试 Uboot 和内核的各种信息。

- 检测处理器类型

Uboot 在调用内核前需要检测系统的处理器类型，并将其保存在某个变量中提供给内核，内核在启动过程中会根据该处理器的类型调用相应的初始化程序。

- 设置内核启动参数

内核在启动过程中会根据该启动参数进行相应的初始化工作。

- 调用内核镜像

值得注意的是存储 Uboot 的存储器不同，Uboot 的执行过程也并不相同，一般来讲 Flash 分为 nor Flash 和 nand Flash 两种：nor Flash 支持芯片内执行（XIP，eXecute In Place），这样代码可以在 Flash 上直接执行而不必复制到 RAM 中去执行。

但是 nand Flash 并不支持 XIP，所以要想执行 nand Flash 上的代码，必须先将其复制到 RAM 中去，然后跳到 RAM 中去执行。如果内核存放在 nor Flash 中，那么可直接跳转到内核中去执行。但通常由于在 nor Flash 中执行代码会有种种限制，而且速度也远不及 RAM 快，所以一般的嵌入式系统都是将内核复制到 RAM 中，然后跳转到 RAM 中去执行。不论哪种情况，在跳到内核执行之前 CPU 的寄存器必须满足以下条件：r0 ＝ 0，r1 ＝ 处理器类型，r2 ＝ 标记列表在 RAM 中的地址。

#### Linux 内核的启动流程（设备和驱动的加载）

关于 Uboot 的启动本课程不做详细介绍，因为本课程的主要内容是内核。在讲述内核启动之前让我们先了解下内核的组成结构：

![image](http://images.gitbook.cn/ef8d4ef0-cdf0-11e7-96b8-f917d0905f72)

其中，

（1）vmlinusx 是 ELF 格式的 Object 文件，这种文件只是各个源代码经过连接以后得到的文件，并不能在 ARM 平台上运行。

（2）经过 objcopy 这个工具转换以后，得到了二进制格式文件 Image，Image 文件相比于 vmlinusx 文件，除了格式不同以外，还被去除了许多注释和调试的信息。

（3）Image 文件经过压缩以后得到了 piggy.gz，这个文件仅仅是 Image 的压缩版，并无其他不同。

（4）接着编译生成另外几个模块文件 misc.o、`big_endian.o`、head.o、head-xscale.o，这几个文件组成一个叫 Bootstrap Loader 的组件，又叫引导程序，编译生成 piggy.o 文件。

（5）最后 piggy.o 文件和 Bootstrap Loader 组成一个 Bootable Kernel Image 文件（可启动文件）。

经过上面的分析不难知道 piggy.o 就是内核镜像，而剩下的几个文件就组成了引导程序。知道了内核的组成结构，Uboot 就是按照内核的组成结构一层一层剥开然后引导内核的：

![image](http://images.gitbook.cn/e5ba10b0-d035-11e7-9c94-71d522a5528f)

可以说 `start_kernel()` 之前的所有工作都是为了将环境准备好，满足 `start_kernel()` 的要求，然后由 `start_kernel()` 开始进行内核的加载：

![image](http://images.gitbook.cn/7deb81e0-ceb8-11e7-aa4d-0bd22aa21c0b)

关于 `start_kernl()` 函数的内容太多，可以通过红色回调函数看出，`start_kernel()` 函数基本是在回调很多对应的注册函数。为了本系列课程的结构性这里就不展开所有知识点讲解，本篇内容接着前一篇设备树的内容重点讲解下设备和驱动的匹配过程。

还记得上一篇讲到的设备树三大作用吗？

- 平台标识；
- 运行时配置；
- 设备信息集合。

接下来我们就看看内核在启动的时候是如何寻找设备，驱动又如何和设备绑定的。

首先在平台目录下可以看到有很多平台描述的文件，如图：

![image](http://images.gitbook.cn/ee941a50-d03f-11e7-8b1e-c1123b04ea34)

有那么多的平台，我们到底要执行哪个平台是首先要考虑的事情。这也是设备三大功能的第一个功能——平台标识。

- 设备树里有对设备根节点的 Compatible 描述，平台文件里有对 `__initconst` 的描述，如果两个字段一致则找到了对应的板级文件，这样就通过设备树把要用的设备平台与其他平台区分开来了，如图：

![image](http://images.gitbook.cn/fc3c9590-d041-11e7-a349-11523d5feb7e)

找到平台后就可以根据回调函数的指针调用该平台的注册函数。这里以飞思卡尔 imx.6dl 平台为例，回调的时候会调用 `imx6q_init_machine()` 函数，如下：

![image](http://images.gitbook.cn/7cb5e0b0-cebb-11e7-9bd4-8f7c3e1b68c2)

这里补充一个知识点，细心的读者也许发现了在 Compatible 字段里用逗号分隔了两个字符串。板级匹配的时候用的是哪个字符串，另外一个字符串又是做什么用？首先后面的字段 "fsl,imx6dl" 是抽象共用平台描述符，前面的字段 "fsl,imx6dl-sabresd" 是通用平台下的具体平台描述符，可以理解为母板和子板的区别。在具体的子板文件中我们可以通过前面的字段进行设备信息的获取，如图：

![image](http://images.gitbook.cn/12cba920-d044-11e7-a349-11523d5feb7e)

- 接着是运行时配置，让内核在启动的时候根据参数设置进行不同的处理。有经验的读者清楚在 Uboot 里也有对 Bootargs 的配置，这里为什么多此一举呢，是为了在 Uboot 中更灵活的对内核启动进行配置。
- 最后的作用就是设备信息集合，这是设备和驱动匹配的核心，也是工作中面对最多的情况。出于这一作用的内容是工作中经常遇到的重点也是难点，我们专门用一篇内容来详细讲解各级设备是如何展开的，并且手把手教你如何定制一套自己的开发板全新案例。