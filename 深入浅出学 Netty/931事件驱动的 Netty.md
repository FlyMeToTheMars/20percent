# 9/31事件驱动的 Netty

## 前言

Netty 官网对自己的描述是一个异步的事件驱动的网络框架。异步如何表现和异步背后的线程模型在上文已经分析过了。

事件驱动是 Netty 中另外一个非常重要的概念。Netty 框架中描述的事件是一种抽象概念，其将框架运行过程中会发生的许多“动作”以事件的概念定义。并且在事件发生时，触发对应的回调方法。对于开发者而言，只需要实现自己感兴趣的事件的回调方法。因此，对于事件的回调方法的实现，构成了对 Netty 的主要使用。

简单的说，了解了 Netty 中的事件，也就掌握了大部分在 Netty 中进行业务开发所要使用的 API 。下面就来逐一的介绍这些事件。

## 事件的线程触发机制

在分析事件的触发条件和触发内容之前，需要再明确几个要点：

- Netty 的事件是一种抽象的概念，事件的触发在代码上表现为`ChannelHandler`上某个具体方法的调用
- 一个`ChannelHandler`会被唯一一个线程所绑定，其事件触发的所有代码都是在这个线程上被串行执行。
- 当`ChannelHandler`没有显示指定绑定的线程时，直接绑定于`ChannelHandler`关联的`Channel`所绑定的线程

查看 Netty 的代码，大部分事件方法都有如下的模板式代码

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191012175823.png)

这个模式方法实际上就是在践行“ChannelHandler上的方法都是在其绑定的线程上串行执行”这个原则。如果要执行事件方法的线程不是其绑定线程，则将事件方法的执行包装为一个 runnable 对象，投入到该绑定线程的任务队列中，等待后续被该线程取出处理。而如果当前线程就是其绑定线程，则直接执行事件方法。

## 事件的传递机制

在前文中我们提到过管道的概念，也就是`pipeline`机制。事件的流转方向根据入站和出站的不同，入站是从`pipeline`头部向尾部传递的，而出站是从尾巴向头部传递。

`pipeline`上事件的传递并不是每一个`ChannelHandler`都会经历，而是只有实现了对应的事件方法的`ChannelHandler`才会被传递到这个事件。并且每一个`ChannelHandler`可以决定是否继续向后传递这个事件。如果想要继续传递这个事件，一般而言都需要调用方法`ctx.fireXXXX`来将事件继续传递。而如果什么都不做的话，事件传递就到此为止了。整体的控制权都在用户的手里。

简而言之就是两个重要原则：

- 实现了对应事件方法的`ChannelHandler`才会传递给对应的事件
- 可以通过`ChannelHandlerContext.fireXXXX`来决定是否继续传递事件

由于`ChannelHandler`可以决定是否继续传递事件，因此后续的事件触发分析都是针对管道中的第一个`ChannelHandler`。

## 公共事件

公共事件被定义在接口`io.netty.channel.ChannelHandler`中。每一个业务实现都会实现这个接口。但是更具体的，一般是要实现进站事件接口或者出站事件接口。单纯只是实现这个接口，则无法实现业务所需。

### handlerAdded

当一个`Channel`的管道`pipeline`上添加了一个`ChannelHandler`实例时，添加事件被触发，`handlerAdded`方法被触发。

这里有个注意点，在一个`Channel`刚生成时，其上还没有绑定线程。此时如果有`ChannelHandler`被添加到管道上，`handlerAdded`方法暂时不会被触发。但是会将需要触发的`handlerAdded`方法的对象实例存储在一个列表中，等到`channel`绑定到一个线程上时，就会从这个列表上拿出所有的实例，触发其`handlerAdded`方法。

为什么会有这样的取舍，主要还是在于 Netty 的设计原则：`ChannelHandler`上的所有方法调用都串行的执行于其唯一绑定线程。通过这种方式，也保证了事件触发的先后顺序。在`ChannelHandler`中，`handlerAdded`方法必然是所有事件中**最先被触发**的，而后才是其他的事件。也很好理解，只有添加了，才能执行后续的事件动作。

### handlerRemoved

当`ChannelHandler`从一个管道上被删除时，`handlerRemoved`事件被触发。

一般而言我们会执行方法`io.netty.channel.ChannelPipeline#remove(java.lang.String)`去删除一个`ChannelHandler`。同样的，基于任何事件都需要在`ChannelHandler`绑定的线程上执行，即使被删除也是一样。如果执行remove的线程就是其绑定线程，则直接触发`handlerRemoved`方法，否则将方法调用包装为runnable任务，投递到线程的任务队列中等待后续执行。

## 入站事件

按照数据的流动方向，数据的读取处理属于入站事件，即从通道流向`ChannelHandler`的。入站事件都定义在`io.netty.channel.ChannelInboundHandler`接口上。大多数时候开发者不会对每一个事件都感兴趣，Netty也提供了一个适配器抽象类`io.netty.channel.ChannelInboundHandlerAdapter`。开发者只需要实现自己感兴趣的事件就好了。

### channelRegistered

当一个通道被注册到一个线程上时，通道注册事件会在通道的管道上被传递。

前面我们分析过，如果一个通道还没有被绑定到线程上时，添加的`ChannelHandler`所有方法都不会执行。而一旦通道注册到线程上时，第一个被触发的是`handlerAdded`事件，紧随其后的就是`ChannleRegistered`事件。

一个通道注册到一个线程上并不是一次性的。还可以从线程上脱离，并且再次注册到另外一个线程上。第二次注册时，该事件依然会被触发。

### channelActive

当`channelRegistered`触发之后，紧跟着是事件`channelActive`的触发。只有当一个通道处于激活状态（对于tcp通道而言，就是tcp通道处于打开状态）并且被注册到一个线程上时，该事件才会被传递。

与`channelRegistered`事件不同，该事件只会被传递一次。一旦触发过一次，后续无论通道是否二次注册到线程，都不会再触发了。

### channelInactive

当一个通道被关闭时，`channelInactive`事件被传递。具体而言，一般这个事件会在我们调用`io.netty.channel.ChannelOutboundInvoker#close()`方法关闭通道时发生。

在Netty中，一个通道被关闭后就结束了，所以这个事件也是个一次性消费事件。

### channelRead

当通道读取到数据时，该事件被触发。在通道上读取数据时Netty使用了`ByteBuf`，由于容量适应的逐步的，如果通道上一次性有许多数据可以读取，则在将通道上的数据全部读取完毕前，可能触发多次`channelRead`事件。

在实际的开发中，一般而言管道中的第一个`ChannelHandler`都是解码器，因此 TCP 是面向流的，可能产生拆包和粘包。如果没有解码器在第一个`handler`的位置对数据进行分割和累积处理，则后续读到的数据可能是错误切分的。这一点会在后文更详细的说明。

### channelReadComplete

当通道开始读取数据时，随着每一次通道读取数据，填充到`ByteBuf`，会触发一次`channelRead`事件。而当通道上这一次数据读取完毕后，则会触发`channelReadComplete`事件。

该事件的触发，意味着这一次的数据读取结束。通道进入下一次读取就绪的等待中。

### channelWritabilityChanged

我们通过方法`io.netty.channel.socket.SocketChannelConfig#setWriteBufferWaterMark`来设置一个通道的可写水平。可以设置高水位和低水位。当通道待发送数据的总大小超过高水位时通道处于不可写状态。当通道待发送数据的的总大小小于低水位时，通道转变为可写状态。

每当通道的可写状态改变时，该事件就会被触发。通道是否可写可以通过方法`io.netty.channel.Channel#isWritable`来确认。

不过通道的可写状态只是一种标识，实际上并不会对数据的读取，发送，写出有任何的影响。这个状态位更多的是给用户来进行某种外部操作的标识使用。

### userEventTriggered

这个方法是用来传递所有非默认事件的“用户”事件。用引号是因为这个方法在 Netty 内部也是被使用的，并不是单单额外提供给开发者使用的。可以举几个例子让大家对这个方法有直观印象。

例子一

比如一个通道的输入流关闭时，如果当前通道支持半关，也就是只关闭输入流。此时就会传递一个`io.netty.channel.socket.ChannelInputShutdownEvent`事件，触发`userEventTriggered`方法

例子二

Netty 内置提供了一个通道空闲检测的`handler`实现。如果一个通道在规定的事件内没有任何 IO 工作，则会传递一个`IdleStateEvent`事件。

### exceptionCaught

当通道执行业务逻辑抛出异常时，则会触发这个事件。

## 出站事件

根据数据的流动方向，从管道流向 Socket 通道的，则是为出站事件。出站事件大多与“写”相关联。出站事件被定义在接口`io.netty.channel.ChannelOutboundHandler`上。和入站事件相同，出站事件也定义了适配器类`io.netty.channel.ChannelOutboundHandlerAdapter`，开发者只需要实现自己关注的事件即可。

出站事件和入站事件有一个明显的不同，入站事件是 Socket 通道上发生了某些变化：或者读取到了数据，或者是注册，然后事件才会传递到方法上。而出站事件是用户意图执行某些方法，触发了事件，最终才传递到通道上。

### bind

当通道执行绑定操作时，该事件会被触发。注意，是绑定调用一开始，该事件就会被触发，此时绑定可能尚未成功（从实际的代码调用来看，应该时候该方法触发时，真实的在 Socket 上的绑定请求还未开始）

### connect

当通道执行连接操作时，该事件会被触发。与`bind`事件相同，该事件触发时，通道上 Socket 实际的连接请求还未开始。

### disconnect

当通道执行终止连接操作时，该事件会被触发。在 TCP 通道上，终止连接等同于关闭通道

### close

当通道执行关闭操作时，该事件会被触发。

### read

在通道上主动调用`read`方法尝试读取数据时，该事件会被触发。在管道上的`read`事件都触发过之后，通道开始读取数据，如果读取到数据，则又会触发到`channelRead`事件等。

### write

在通道上调用`write`方法时，就会触发该事件。需要写入的数据也会一路传递，直到最终进入通道的待发送队列。

### flush

在通道上调用`flush`方法时，就会触发该事件。执行`write`方法时，数据只是进入了通道的待发送队列，并不会真正的将数据写入socket通道的发送缓冲区。而需要将数据刷出到socket通道的发送缓冲区，则需要调用通道的`flush`方法。此时就会触发该事件。

这篇文章我们详细讨论了 Netty 中的事件机制，从事件的定义概念，到事件的传递机制进行了原理层面的分析。而事件在 Netty4 中是一种概念形式的存在，具体在代码上，就表现为了几个核心定义的 API 接口。这几个核心 API 的使用，基本就决定了在 Netty 中的数据流转表现。

这种概念化的事件定义不是很好理解，实际上，在 Netty3 中，事件的定义确确实实是一个个不同的 Event 类。而事件的传递也是`Event`对象在不同处理器上传递的过程，不过显然，每次 IO 都包装为一个事件会带来较大的浪费和 GC 压力。于是到了 Netty4 中，演变为了这种概念化的事件，事件的传递变成了相同的 API 接口在管道上按照顺序被触发。

从开始到现在的学习，使用 Netty 开发应该已经基本无压力了，但是我们还少了最后一个关键，就是编解码的处理。编解码的处理在项目开发中甚为重要，其同时还解决了拆包粘包的问题。那么下一个章节就是来介绍编解码的部分。