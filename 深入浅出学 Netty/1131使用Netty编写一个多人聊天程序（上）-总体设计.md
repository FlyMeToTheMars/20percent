# 11/31使用Netty编写一个多人聊天程序（上）-总体设计

## 前言

在入门篇中我们介绍了Netty的主要组件，线程模型，以及基本的使用方式；掌握了这些内容，就足以在实际的项目开发中使用Netty来进行网络程序的构建。从本章开始，我们将以实际中开发的项目作为例子，进行Netty实战讲解。

本篇文章我们将实现一个网络多人聊天程序。

## 需求澄清

对于该网络多人聊天项目，需要实现的功能有：

1. 支持客户端以用户名发送注册申请，服务端响应是否成功，成功的注册名需要全局唯一。
2. 支持客户端以用户名进行登陆。
3. 支持单客户端对单客户端进行消息发送和接收。
4. 支持客户端以群聊名发送群聊创建申请，服务端响应是否成功，注册的群聊名需要全局唯一。
5. 支持客户端使用群聊名加入一个群聊。
6. 在群聊中，任意客户端发送的消息，其他客户端均可以收到。

考虑到实战项目的讲解内容的需要，我们将消息定义为本文消息，并且将不影响Netty学习的数据持久化，离线消息等需求剥离，重点集中在链接建立，消息接收，消息发送，编解码上。

## 协议制定

需求是实现一个多人聊天应用，为了彼此通信，首先要完成的是通信协议的选择或制定。可以选择开源协议诸如 XMPP（基于 XML 制定的可扩展通讯协议），也可以自行制定。为了保持简单和集中目标，在这里我们选择自行制定通讯协议。

从需求的角度出发，客户端会发送的消息类型有：

1. 注册消息
2. 登陆消息
3. 发送给特定客户端的消息
4. 群聊创建消息
5. 加入群聊消息
6. 发送到群聊的消息
7. 心跳消息

会收到的消息类型有：

1. 注册响应消息
2. 登陆响应消息
3. 来自其他客户端的消息
4. 群聊创建响应消息
5. 加入群聊响应消息
6. 来自群聊的消息。
7. 心跳响应

发送消息和接收消息是天然区分的，不需要担心混淆。为了区分发送消息和接收消息各自的类型，我们使用一个字节作为标识位来进行类型区分，并且将这个标识位放在消息的最开始位置。现在我们有了一个最初步的消息协议，只包含一个字节的标识位，如下

| 名称     | 作用                 | 长度 |
| :------- | :------------------- | :--- |
| 协议类型 | 用于区分消息体的类型 | 1    |

对于发送消息，协议类型字段的取值可能是：

- 1：注册消息
- 2：登陆消息
- 3：发送给特定客户端的消息
- 4：群聊创建消息
- 5：加入群聊消息
- 6：发送到群聊的消息
- 7：在线心跳上送消息

对于接收消息，协议类型字段的取值可能是：

- 1：注册响应消息
- 2：登陆响应消息
- 3：来自其他客户端的消息
- 4：群聊创建响应消息
- 5：加入群聊响应消息
- 6：来自群聊的消息
- 7：心跳响应消息

根据消息类型的不同，其后跟随的字段内容也可以不同，因此我们需要针对每一种消息类型单独进行罗列。

首先是针对发送消息进行逐一设计，下面来看。

**注册消息**

注册消息需要发送客户端的注册名，因此我们可以将注册消息的完整协议设计为

| 名称       | 作用                                        | 长度   |
| :--------- | :------------------------------------------ | :----- |
| 协议类型   | 用于区分消息体的类型                        | 1      |
| 注册名长度 | 用于标识随后注册名的长度，使用4字节整型表示 | 4      |
| 注册名     | 客户端的注册名，使用UTF8编码                | 不定长 |

**登陆消息**

登陆消息需要发送客户端的注册名，需要传输的内容与注册消息类似，在设计上可以参考，具体如下

| 名称       | 作用                                        | 长度   |
| :--------- | :------------------------------------------ | :----- |
| 协议类型   | 用于区分消息体的类型                        | 1      |
| 登陆名长度 | 用于标识随后登陆名的长度，使用4字节整型表示 | 4      |
| 登陆名     | 客户端的登陆名，使用UTF8编码                | 不定长 |

**发送给特定客户端的消息**

给客户端发送消息，显然需要包含目的客户端的名称；其次是消息内容。考虑这两点，协议可以设计为

| 名称               | 作用                                    | 长度   |
| :----------------- | :-------------------------------------- | :----- |
| 协议类型           | 用于区分消息体的类型                    | 1      |
| 目的客户端名称长度 | 用于标识随后的客户端名称长度，4字节整型 | 4      |
| 客户端名称         | UTF8编码标识的名称                      | 不定长 |
| 消息长度           | 用于标识随后的消息长度，4字节整型       | 4      |
| 消息               | UTF8编码的消息内容                      | 不定长 |

**群聊创建消息**

创建群聊，需要发送群聊名称，类似于登陆和注册，协议可以设计为

| 名称       | 作用                                        | 长度   |
| :--------- | :------------------------------------------ | :----- |
| 协议类型   | 用于区分消息体的类型                        | 1      |
| 群聊名长度 | 用于标识随后群聊名的长度，使用4字节整型表示 | 4      |
| 群聊名     | UTF8表示的群聊名                            | 不定长 |

**加入群聊消息**

加入群聊也需要发送群聊名称，协议上可以参考群聊创建，如下

| 名称       | 作用                                        | 长度   |
| :--------- | :------------------------------------------ | :----- |
| 协议类型   | 用于区分消息体的类型                        | 1      |
| 群聊名长度 | 用于标识随后群聊名的长度，使用4字节整型表示 | 4      |
| 群聊名     | UTF8表示的群聊名                            | 不定长 |

**发送到群聊的消息**

发送给群聊的消息和发送给单客户端的消息类似，只不过客户端标识被替换为了群聊标识，因此协议可以设计为

| 名称         | 作用                                  | 长度   |
| :----------- | :------------------------------------ | :----- |
| 协议类型     | 用于区分消息体的类型                  | 1      |
| 群聊名称长度 | 用于标识随后的群聊名称长度，4字节整型 | 4      |
| 群聊名称     | UTF8编码标识的名称                    | 不定长 |
| 消息长度     | 用于标识随后的消息长度，4字节整型     | 4      |
| 消息         | UTF8编码的消息内容                    | 不定长 |

**在线心跳上送消息**

心跳消息本身只是用于客户端存活确认，因此除了消息类型外，并不携带其他信息负载，协议设计如下

| 名称     | 作用                 | 长度 |
| :------- | :------------------- | :--- |
| 协议类型 | 用于区分消息体的类型 | 1    |

接着我们设计响应消息的协议。

**注册响应消息**

响应消息只需要表示成功与否，用一个字节长度的表示位即可，协议可以设计如下

| 名称     | 作用                                  | 长度   |
| :------- | :------------------------------------ | :----- |
| 协议类型 | 用于区分消息体的类型                  | 1      |
| 成功标识 | 0代表成功，其他值则代表不同的失败情况 | 1      |
| 消息长度 | 整型，代表消息字段的长度              | 4      |
| 消息     | 用于对成功标示的文字描述              | 不定长 |

**登陆响应消息**

登陆响应消息与注册响应消息完全一致，只不过协议类型的取值不同，这里就不展示了。

**来自其他客户端的消息**

为了知道消息的来源处，必然要包含其他客户端的客户端名称，此外还需要包含发送的内容体，因此协议可以设计为

| 名称               | 作用                                    | 长度   |
| :----------------- | :-------------------------------------- | :----- |
| 协议类型           | 用于区分消息体的类型                    | 1      |
| 来源客户端名称长度 | 用于标识随后的客户端名称长度，4字节整型 | 4      |
| 来源客户端名称     | UTF8编码标识的名称                      | 不定长 |
| 消息长度           | 用于标识随后的消息长度，4字节整型       | 4      |
| 消息               | UTF8编码的消息内容                      | 不定长 |

**群聊创建响应消息**

该响应消息作用和登陆响应一致，只不过协议类型的取值不同，这里就不展示了。

**加入群聊响应消息**

该响应消息作用和登陆响应一致，只不过协议类型的取值不同，这里就不展示了。

**来自群聊的消息**

该消息和“来自其他客户端的消息”相似，只不过来源客户端名称修改为群聊名称，因此设计如下

| 名称               | 作用                                    | 长度   |
| :----------------- | :-------------------------------------- | :----- |
| 协议类型           | 用于区分消息体的类型                    | 1      |
| 群聊名称长度       | 用于标识随后的群聊名称长度，4字节整型   | 4      |
| 群聊名称           | UTF8编码标识的名称                      | 不定长 |
| 来源客户端名称长度 | 用于标识随后的客户端名称长度，4字节整型 | 4      |
| 来源客户端名称     | UTF8编码标识的名称                      | 不定长 |
| 消息长度           | 用于标识随后的消息长度，4字节整型       | 4      |
| 消息               | UTF8编码的消息内容                      | 不定长 |

**心跳响应**

心跳响应用于向客户端确认心跳的接收，也可以用于让客户端确认当前链接有效。

| 名称     | 作用                 | 长度 |
| :------- | :------------------- | :--- |
| 协议类型 | 用于区分消息体的类型 | 1    |

至此，内容体的协议设计就完成了。接下来需要考虑的是该协议对区分一个消息是否完整有无困难。查阅上面设计的协议内容，每个字段或者或定长字段，或者长度为其他定长字段所修饰，因此已经足够解码器使用该协议进行报文分割了。

不过上面的协议因为会涉及到定长字段和不定长字段，分割报文时还需要读取几个字段的信息，不够方便。因此我们将我们讨论确定的协议内容认定内容协议，为整个报文的报文体。而报文协议采用定长报文头加报文体的格式，如下

| 名称     | 内容                                   | 长度   |
| :------- | :------------------------------------- | :----- |
| 报文长度 | 整型变量，表示报文长度                 | 4      |
| 报文内容 | 消息内容，其内容遵循上面确定的内容协议 | 不定长 |

到这里，我们的通讯协议就全部设计完毕了。

## 服务端设计

### 消息对象

对于服务端来说，消息的编解码是处理消息的第一步，将不同消息映射到不同的实体上，方便后续的业务逻辑处理代码进行识别和处理。设计实体我们从以下几个方面去考虑：

- 消息实体区分为从客户端至服务端的**命令**和从服务端到客户端的**接收**。
- 使用枚举类来对命令和接收进行类型区分。
- 将命令和接收设计为 2 个单独的接口，该接口的 type 方法可以返回对应的枚举对象，用于区分消息的类型。
- 在上述基础上按照协议实现不同的命令和接收。

根据上述的指导原则，完成后的消息类设计如下

![img](https://images.gitbook.cn/15746739749196)

代码托管于：https://gitee.com/eric_ds/learnNetty/tree/master/practise01

### 持久化实体

服务端在运行过程中有一些业务实体信息需要被持久化，才能满足软件功能。根据需求澄清中的内容，可识别的实体有：

- 发送或者接收的消息
- 客户端信息
- 群聊信息
- 客户端加入的群聊关系信息

考虑到不需要实现消息持久化和离线消息，因此消息本身不需要作为实体来持久化。客户端需要作为实体来存储，才能实现登陆和路由；群聊需要作为实体化来存储，才能实现加入和发送到群聊功能；关系信息作为实体化来存储，才能实现群聊内客户端集合查找功能。由于项目经过了简化，客户端信息和群聊信息本身都只有一个唯一ID和唯一标识，关系实体的属性包含有：唯一ID，客户端ID，群聊ID；三者都比较简单，因此我们省略实体类，直接设计实体相关的数据访问层，也就是DAO。

首先是根据实体设计访问实体的相关接口；其次根据接口给出对应的实现，这里的实现依据数据存储的具体位置不同而有不同的实现。比如可以将数据简单的保存在服务端JVM内；也可以将数据存储至共享缓存如Redis中；也可以将数据存储在数据库上。在这里，为了简单起见，我们将实体信息保存在JVM的内存中。完成的代码设计如下

![img](https://images.gitbook.cn/15746739749217)

为了方便获取我们的数据访问对象实例，我们设计了额外的工厂接口，`DAOFactory`，该接口用户维护，生成，获取数据访问对象实例。通过该工厂方法，隐藏了具体的`ClientDAO`，`GroupDAO`和`RelationDAO`实现，方便于后续持久化实现的替换。

### 路由功能

在线聊天而言，最重要的就是对消息的路由功能。按照需求，这里存在两种消息：客户端到客户端，发送到群聊；两种消息的模式不同，对应的路由设计也不同。

首先来考虑客户端到客户端的消息路由方式。在 Netty 中，一个客户端建立链接后，会产生一个`io.netty.channel.socket.SocketChannel`对象。因此我们可以建立一个客户端标识到其`SocketChannel`对象的映射存储，当收到客户端A发送给客户端B的消息时，在映射中找到客户端B对应的`SocketChannel`，通过`SocketChannel`的`write`方法，就可以将对象的消息发送给客户端B。当然，收发消息的协议不同，并不是直接的转发关系，需要经过服务层的转换。

在考虑发送到群聊的消息，显然比客户端要复杂一些。一个群聊中会包含多个在线的客户端，显然我们可以使用一个`Set`对象来存储某个具体的群聊中所有的在线客户端`SocketChannel`对象。当收到发送给群聊的消息时，首先通过群聊名称的映射关系找到对应的群聊内客户端标识集合。遍历该集合，针对每一个客户端通道，将消息发送给对应的客户端；当然，在遍历的过程，要忽略消息的发送客户端。

以上的两个信息，我们称之为路由表；前者称之为单聊路由表，后者称之群聊路由表。路由表维持的都是在线的客户端`SocketChannel`对象。所以在客户端上下线的时候都需要对路由表信息进行更新。

客户端上线的时候，通过登录，服务端查询得到客户端 ID。将客户端 ID 和`SocketChannel`对象更新到单聊路由表。通过客户端查询该客户端 ID 绑定的群聊 ID 集合，使用群聊 ID 获得群聊路由表，在每一个路由表中加入该客户端的`SocketChannel`对象。

客户端离线的时候，将单聊路由表中的该客户端 ID 元素删除。通过客户端 ID 查询绑定的群聊 ID 集合，使用群聊ID获取群聊路由表，在每一个群聊路由表中，删除该客户端的`SocketChannel`对象。

**并发安全**

客户端在上下线的时候都需要对路由表进行操作。考虑一种极端情况，客户端网络掉线后快速上线。此时处理客户端离线的线程和处理客户端上线的线程不是同一个，两个线程对路由表的操作顺序不定（CPU 调度无法预测）。可能造成处理上线的线程先操作路由表，离线的线程后操作路由表。此时就会导致路由表中的数据错误。因此，对于在路由表中执行的添加和删除操作，需要考虑在并发下的影响。

上线情况的添加，需要使用并发安全的`java.util.concurrent.ConcurrentMap#putIfAbsent`方法。而如果在添加的时候遇到旧值仍然存在的情况，需要判断放入的值和旧值对应的`SocketChannel`哪一个才是真正可以连通的链接，进行保留。

离线情况下的删除，需要使用并发安全的`java.util.concurrent.ConcurrentMap#remove`方法，在删除的时候确认待删除的`SocketChannel`是否是目标对象。

## 思考总结

本文从项目的需求开始，先对项目的需求进行澄清和梳理，这也是项目开始的标准步骤之一，和客户沟通需求；当然，这里的客户就是我们自己了。

在确认多人聊天的需求基础上，首先完成的是通讯协议的制订。通讯协议承载着整个系统的信息交互功能，需要能够传递所有情况下所需要的必备信息，在制订的时候还需要考虑如何设计才能解码器高效的实现对报文的分割。通讯协议制订完成后，最后一步是服务端设计。

服务端设计主要要考虑三个方面的内容：

1. 消息对象的设计；
2. 持久化的实体设计；
3. 路由功能设计。

路由功能是其中最为重要和核心的部分，消息队形和持久化实体都是为了支撑路由功能本身。

本文中完成了对服务端的重点方面的核心设计，下一篇文章中我们将开始服务端代码的撰写。