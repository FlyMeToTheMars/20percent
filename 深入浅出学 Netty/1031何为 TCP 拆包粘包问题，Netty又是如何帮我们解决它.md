# 10/31何为 TCP 拆包粘包问题，Netty又是如何帮我们解决它

## 粘包和拆包现象

在网络通信中，客户端向服务端发送两个数据包，C1 和 C2 如下图：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015233844.png)

站在客户端的角度，它是发送了两个不同的数据包。但是从服务端接受数据的角度来看就不一定了。可能出现的情况有三种。

第一种也是最符合直觉的，服务端按照客户端发送的顺序收到了数据包：D1 和 D2。

第二种，服务端第一次读取数据时读到了 D1 的一部分，再次读取时读取到了 D1 的剩余部分，第三次读取，读取完毕了D2。

用图来表达就是：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015233916.png)

第三种，服务端读取一次数据，就完全读取到了 D1 和 D2。就如下图：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015233937.png)

以上的第二种现象被称之为拆包，也就是一个完整的业务数据包被拆分到多次 Socket 读取的结果中。而第三种先想想被称之为粘包，也就是在一次 Socket 数据读取中，读取到了多个业务数据包。

## 原因分析

了解了现象，我们再来分析下原因。首先，TCP 是传输层协议，是无法感知到应用层的数据分包大小的。可想而知，在 TCP 层面进行的数据传输，其数据切分必然无法和应用层协议保持一致，因此会出现拆包粘包也就不足为奇。如果只是分析到这个层面未免流于表面，下面针对各种可能性进行梳理。

### 滑动窗口导致的拆包

TCP 使用滑动窗口算法进行流量控制。发送方有一个发送窗口，只有处于窗口内的数据才能允许被发送出去。如果发送的 TCP 报文一直没有收到对象的确认响应，则发送窗口的可用窗口会逐渐变小最终为 0。接收方也有一个接收窗口，只有处于接收窗口内的数据，TCP 确保其顺序正确才能被应用层读取。

如果客户端在发送数据时，发送窗口不足以容纳完整的业务数据包，则会导致发送窗口内的部分业务数据被发送到了对端。这就是因为发送窗口不足产生的拆包。

### 超过TCP包大小导致的拆包

网络中传输一个数据包有固定的长度大小。一般而言，在网络上传输数据，最大传输单元为 1500 字节。这 1500 字节还需要包含 TCP 报文头和 IP 报文头，因此留给业务数据的最大长度一般为 1460 字节。这个长度一般被称为 MSS，最大报文长度。

如果客户端需要发送的一个业务报文超过了 MSS，则操作系统会自动的按照 MSS 拆分成多个 TCP 数据包在进行发送。自然，这种情况在接收端收到的就不完整的数据报文。

### 滑动窗口导致的粘包

上面提到过，接收方也有一个滑动窗口。如果接收方应用程序一直没有从TCP 连接中读取数据，则该接收窗口会逐渐被数据填满。而此时接收方应用程序从TCP读取数据时，可以一次性全部读取接收窗口内的数据。而这一个窗口的数据可能实际上包含了多个业务数据包。但是对于应用层而言，是无法分辨的。

## 解决粘包和拆包的手段

TCP 是面向流的，无法感知应用层的数据包的分界。应用程序也决定不了传输层是拆包还是粘包。如果直接从 TCP 连接中读取数据的话，是无法进行数据边界判断的。但是可以从协议设计的角度出发，人为的进行数据包边界的制定和解析。几种常见的协议设计思路有：

- 业务数据使用定长报文：此种情况下，接收方只要读取到足够的数据长度就分离出一个业务数据报文。
- 使用特殊的消息分隔符：此种情况下，接收方检查每一个收到的字节，一旦某段字节序列符合分隔符特征，接收方就可以分离出这段数据报文
- 使用报文头+报文体的设计：这种设计中，一般报文头是一个定长或者不定长的数据，其中会包含报文体的长度或者总报文的长度。这样，接收方应用程序在读取报文头之后就可以知道整体的报文长度或者剩余的报文体的长度，依照长度，就可以对一个数据报文进行分离。

## Netty 如何解决粘包和拆包

根据上个章节给出的解决粘包拆包的三种协议设计思路，Netty 也提供了不同的实现来进行支撑。一般而言，解码器需要放在管道的开头，第一个处理数据，才能实现分割的目的。

**使用定长报文协议**

针对定长报文协议，Netty 提供了`io.netty.handler.codec.FixedLengthFrameDecoder`解码器。该解码器可以按照指定的字节长度将数据分离出来称为一个报文。

比如其可以将字节流

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015223228.png)

解码为

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015233754.png)

的三个业务数据包。

该解码类的使用也很简单，只需要传入一个整型变量作为构造方法入参，如`new FixedLengthFrameDecoder(int)`。该传入的整型变量就是一个业务数据报文的协议长度。

**使用特殊的消息分隔符协议**

针对使用特殊的消息分割符作为数据的边界的情况，Netty 提供了`io.netty.handler.codec.DelimiterBasedFrameDecoder`作为支持。该解码器可以指定一段二进制序列作为分隔符，其会不断的累积从通道读取的数据并且检查其数据是否有符合分割符的二进制序列。一旦发现符合要求的分割符序列，则以分隔符作为边界分离数据报文。

最常用的构造方法如下`DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf delimiter)`。`maxFrameLength`是确定最大读取长度，超过这个长度还未发现分隔符则抛出异常；`delimiter`存储分隔符内容。

很多协议以换行符作为消息分隔符，比如 FTP 协议。如果是这种情况，Netty直接提供了`io.netty.handler.codec.LineBasedFrameDecoder`解码器作为支持。该解码同时支持以`\r`和`\r\n`作为分隔符。

**使用报文头+报文体协议**

使用报文头+报文体的协议设计，Netty 提供了`io.netty.handler.codec.LengthFieldBasedFrameDecoder`解码器作为支持。这个解码器比较复杂一些，其有四个属性，分别是：

- **lengthFieldOffset**：该属性意味着报文长度字段在整体报文中的偏移量
- **lengthFieldLength**：该属性意味着长度字段本身的字节长度，常见取值有1,2,4。该属性的值默认情况下指代报文体的长度。
- **lengthAdjustment**：该属性意味着在读取完毕`lengthFieldLength`后，剩余需要读取的字节数为`lengthFieldLength`+`lengthAdjustment`的长度。
- **initialBytesToStrip**:该属性意味着读取到的完整报文需要跳过一段长度的字节后的结果作为报文向后进行传递。

举个例子，令

```java
lengthFieldOffset   =0
lengthFieldLength   =2
```

可以将一段报文进行解码，如下

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015233643.png)

从报文的第0位开始读取长度字段的数据，长度字段自身长度为 2，意味着长度字段本身是个无符号 short。**默认情况下**，长度字段的值代表的是后续报文体的长度。0x000c 是十进制的 12。意味着报文体的长度是 12。所以接下来读取了 12 字节长度的内容。

假设我们传递给后方的报文不需要包含长度字段，可以令

```java
lengthFieldOffset   =0
lengthFieldLength   =2
initialBytesToStrip =2
```

此时，在解码出一个业务报文后，会把读取指针向后移动2个字节，也就是跳过报文头的 2 个字节。形象的表达如下

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191015234404.png)

默认情况下，认为读取完毕长度字段后，后续的内容就是报文体了。但是有时候长度字段和报文体之间还会间隔一些数据，此时需要读取的总字节数就不仅仅只是`lengthFieldLength`了，还需要加上`lengthAdjustment`的修正

```java
lengthFieldOffset   =0
lengthFieldLength   =2
lengthAdjustment =2
```

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191016014312.png)

`lengthAdjustment`的值即为`Header 1`的长度。所以在读取完length字段的数据，确定报文长度为 12，但是继续读取的总长度为12+2=14 字节。

## 自定义解码类

Netty不仅仅提供了上面介绍的解码类，实际上，Netty提供了非常多协议的编解码类。这使得大部分流行协议的编解码开发工作基本就不需要了。Netty提供的编解码类都在项目`netty-codec`中。引入Maven依赖，即可开箱即用大部分协议实现。

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-codec</artifactId>
    <version>4.1.42.Final</version>
</dependency>
```

而如果应用层协议是自定义的，且上面介绍的几个解码器都不能满足，可以考虑自行扩展。事实上，大部分的解码器类都继承自`io.netty.handler.codec.ByteToMessageDecoder`类。

从类名就可以看出，这个抽象类的主要作用就是二进制数据转换为一个数据消息。该抽象类只有一个抽象方法需要实现，代码如下

```java
class DemoDecoder extends ByteToMessageDecoder
    {

        @Override
        protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
        {
        }
    }
```

显然，`decode`方法就实现了解码的作用。解释下三个参数：

- `ctx`：存储着当前`ChannelHandler`的一些上下文信息，主要用于事件的传递，在解码过程中可以忽略该参数
- `in`：存储着当前从通道读取的未解码的全部数据
- `out`：存储着目前已经解码出来的消息对象

看了三个参数，`decode`方法要如何实现已经很明显了。那就是根据业务协议规则，从`in`当中分析确定一个业务数据报文，将二进制数据解码为业务对象，放入`out`列表中。循环该过程，直到`in`中无法再分离出来一个业务数据，方法结束。

`ByteToMessageDecoder`在该方法的调用结束后，会将`out`中的数据发送到后面的`ChannelHandler`，通过触发`channelRead`事件。

## 总结与思考

本篇文章，阐述了拆包和粘包的定义与现象，也介绍了其对应的几种表现。从拆包粘包的产生原因入手，提出了几种常见的解决手段。而这几种处理的手段，Netty 都为我们提供了内置的支持。详细的介绍了这几种Netty 为我们提供的解码器后，还介绍了自定义解码器的方式。有效利用这几种方式，常规的编解码就不成问题了。除了这种内置的编解码支持，Netty 还贴心的为我们提供了大量的现成协议的编解码支持，诸如有FTP，HTTP 等等。

到这里为止，我们介绍了使用 Netty 开发网络应用程序需要的方方面面的知识。那一个大章节，我们将进入实战阶段。会使用实际当中的项目作为例子，使用 Netty 完成实战项目演练。