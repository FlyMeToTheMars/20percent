# 24/31Netty 内存池设计之内存页申请与分配

### 引言

网络 IO 框架，最大的开销往往并不是在业务处理的环节，而是在高负载高并发下的 byte[] 对象申请或者 ByteBuffer 申请。很多时候，这些对象只是短暂地用于承载从通道读取数据或者向通道写出数据。在完成这个职能后，这些对象不再使用被 GC 回收。

当系统的负载很高时，频繁的申请 byte[] 或 ByteBuffer 对象，对内存的压力是很大的，很容易在短时间内消耗大量的内存。此时就只能等待 GC 将内存回收后系统才能继续运作。从 JVM 的监控表现来看，就是 GC 执行得十分频繁，耗时也多。表现在应用性能上，就是会出现时延毛刺和吞吐降低等情况。

Netty 4 相比于 Netty 3 有一个很大改变在于实现了自行管理的内存池，内存的申请和释放都在内存池上进行，就不再将这部分压力转嫁给 GC，带来了更平滑的吞吐和时延表现。

### 如何管理一块连续内存

内存池，其基本作用就是提供内存的申请和释放。而为了在这个过程中减少 GC，申请和释放的空间必然是其本身持有，不是在申请和释放的过程中再次向 JVM 申请。因此内存池本身一定是持有一大块可以用于分配的内存。对于 socket 通道而言，其数据读写的载体是 byte[] 对象。那么内存池的设计就可以简化为如何在一个 byte[] 上高效的申请和释放。

对于申请而言，其难度在于两个方面：

- 如何判断申请的长度在对应的 byte[] 存在足够的空闲空间。
- 如何寻找申请长度在 byte[] 上对应的空闲空间。

让我们先略过问题一，先关注到问题二。初始情况下，在一个“空白”的 byte[] 上申请空间是最容易的，因为此时只需要判断数组的长度和申请的长度就能明确是否可以申请，并且可以在任意足够长度的下标处选择其作为起点进行空间分配。

但是进行第二次分配的时候就很麻烦了。我们可以使用一个变量用来记录当前 byte[] 剩余可分配的空间，可以可以快速判断是否有足够的空间进行分配。不过在具体分配的时候就需要避开之前已经分配的空间，而如果去寻找之前分配的空间就成了首要问题。

我们以形象的场景来分析这个问题。假定一开始我们有 16 个字节的内存区域可以分配，如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224131420.png)

如果要申请一个 8 字节的空间，申请后的情况可能是：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224131739.png)

也可能是：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224131800.png)

显然，对于第二种情况，如果还要申请一块 8 字节的空间，虽然整体而言有可以分配的容量，却也是无法申请到空间了。因此，在分配空间的时候应该优先采用第一种分配模式的模式，尽可能的靠前分配，减少碎片空间的产生。

再考虑下分配时寻找空间的问题，显然需要有一种方式来标记已经被使用的空间，再分配的时候避免分配空间的重叠（重叠的空间会带来数据的紊乱）。

最最简单的思路，使用位图来标记每一个可以分配的最小单位。假定可以分配的最小单位是 1k 的字节。16 个 1k 的 byte[] 就可以使用 byte[2] 来表示是否使用中。在检查分配的时候，从头开始遍历位图，当发现空闲空间时开始标记计算，如果在遇到不可用区域前满足了申请长度，则表示可以申请成功。用伪代码表达如下：

```java
public int findAvailable(Bitmap bit,int length){
    int index=-1;
    for(int i=0;i<bit.size();i++){
        //为 true 意味着该位可用
        if(it.get(i)==true){
            if(index==-1){
                index=i;
            }
            else if(i-index==length){
                return i;
            }
        }
        else{
            index=-1;
        }
    }
    return -1;
}
```

这种查找方法无疑效率是很低的。并且在空间碎片化程度很高的时候，可能会出现空闲空间的总容量足够，但是却无法分配足够长度的连续空间的问题。因此无论是通过记录空闲空间总量来判断是否可以分配以及线性查找方式确认分配空间起始标识的做法，两者都是不可取的。

废弃掉这个解决方案，再回头思考判断是否可以申请的问题，实际上应该使用当前内存池最大连续长度来判断是否可以申请。如果申请的长度连最大空闲连续长度都无法满足，必然是无法申请的。

而对于查找而言，之前我们的思路是线性查找，思路如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224145522.png)

提升效率，可以想到的是将线性查找 O(n) 换成二分查找 O(logn)。观察上面的示意图，判断分配单位是否空闲只有一个维度；如果我们增加更多的维度，每一层维度都是下层维度的聚合，那么查询上层维度显然就更快了，因为上层维度的长度更短。从这个角度出发，我们可以将查找的思路抽象为：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224152308.png)

显然，要申请一个空间为 4 的区域，从维度 2 开始寻找，只需要寻找 2 个空闲的区域即可；而从维度 1 开始寻找，则需要寻找连续的 4 个区域，寻找的时间成本就变为 2 倍。

推而广之，我们可以将维度继续升高，最终会变成如下的情况：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224152929.png)

这种表达方式就变成了一颗**完全二叉树**。当需要申请空间时，首先要找到合适的维度。为此，就需要对申请的大小进行规范化，不能再申请任意的大小（只需要最终给出的大小大于等于申请的大小，就是满足客户方要求的），申请的大小必须是某一个维度上的单位值（比如上图的 1、2、4、8、16）。

申请的时候从顶层维度查找，如果申请大小不相符则向下下级维度继续查询。查询到符合的维度后，在该维度上遍历，确认可以使用的区域。

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224154821.png)

比如维度 3 上第一个区域被使用了，意味着其管理的内存空间的 1、2、3、4 处于被使用状态。

维度上的每一个区域都标记了当前管理区域可以分配的最大连续空间。仍然以上图为例，如果维度3的第一个区域被使用了，其可分配空间下降为 0。此时其父节点，也就是维度 4 的第一个区域，显然无法继续分配大小为 8 的空间了。其能分配的空间为 **8-4=4**。

因此，当一个维度上的某个区域被分配后，应该向上更新父节点区域的可分配长度大小。父节点的可分配大小取决于 2 个子节点。当两个子节点都没有分配的情况下，父节点的可分配大小是 2 个子节点之和，或者说此时是初始值。如果两个子节点有一个分配后，父节点的可分配大小应该是 2 个子节点中较大的那个值。

这个更新大小的动作应该不断向上执行，到达根节点。比如申请 1k 的空间，申请成功后，内存池应该如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224165919.png)

如果此时要再申请 2k 的大小，内存池变化如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191224170124.png)

通过这种方式，我们同时解决了确认是否可分配以及如何分配两个问题，根据上面的过程，我们可以将对一块连续内存区域的分配算法描述如下：

- 一块连续的内存区域由 2n 个连续的单位空间构成。
- 采用完全二叉树管理 2n 个连续的单位空间，每一个单位空间对应一个叶子节点。
- 节点的值代表该节点对应的内存区域内可以分配的连续空间长度，节点的初始值对应于其管理的区域大小。
- 如果两个节点的值都是初始值，则父节点的值也是初始值，否则父节点的值是 2 个子节点的值中的较大者。
- 申请空间时，首先将申请大小规范化不小于其值的 2n 大小，称为规范大小。
- 规范大小实际上就是某一个具体维度上的单位大小，也就是说通过规范大小，可以确定要分配的空间所处的维度。
- 如果根节点的值小于规范大小，意味着无法分配。根节点的值大于等于规范大小，则存在可以分配的空间。
- 如果存在可以分配的空间，则从根节点开始向下寻找。如果当前节点的值大于或者等于规范大小，则继续从子节点中寻找直到到达规范大小对应的维度。该维度上找到的节点的值与规范大小相等的节点可用于分配空间。
- 将分配节点的值更新为 0，按照规则更新父节点的值，直到根节点为止。

### Netty 的做法

上文我们分析了一种对连续内存空间的高效管理的办法。在 Netty 中采用了类似的算法，但是采用了一种不直观的表述方式，如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191225104741.png)

每个节点存储的值不是该节点管理的空间大小，而是该节点代表的子树能分配的最小深度（深度越小，意味着越靠近根节点）。节点管理内存大小是 2h-n 个内存单位（比如上图的 1k），h 是管理内存空间的二叉树的最大深度，n是该节点的深度。也就是说，节点的深度决定了其管理的内存大小。

如果一个节点的值大于 h，则意味着该节点没有空间可以再分配内存了。Netty 虽然换了一种表述方式，但是其本质是相同的，因此我们可以将其分配流程整理如下：

- 一块连续的内存区域由 2n 个连续的单位空间构成。
- 采用完全二叉树管理 2n 个连续的单位空间，每一个单位空间对应一个叶子节点。
- 完全二叉树的高度为 h，每一个节点管理的最大单位空间数量为 2h-n，n 为当前节点的深度。
- 节点的值代表该节点当前最大可以分配的空间所在的深度，也就是可以分配的最小深度。节点的初始值与节点的深度相同。
- 如果两个节点的值都是初始值，则父节点的值也是初始值，否则父节点的值是 2 个子节点的值中的**较小**者。
- 申请空间时，首先将申请大小规范化不小于其值的 2d * 单位空间（比如1k）大小，获取 d 值，称为规范大小。
- 规范大小实际上就是所要分配合适空间大小的节点对应的深度。
- 如果根节点的值小于规范大小，意味着可以分配。根节点的值大于等于规范大小，则意味着对应的深度已经分配完毕了，本次申请无法成功。
- 如果存在可以分配的空间，则从根节点开始向下寻找直到到达对应的深度。寻找过程中，如果左子节点的值小于规范大小则尝试右子节点。
- 到达对应深度的节点即为可以分配的节点。将分配节点的值更新为 h+1，按照规则更新父节点的值，直到根节点为止。

仍然以上图为例，本次申请一个 2k 的大小。2k 的大小为 24-3 * 1k，因此规范大小为 3。从根节点开始寻找，最终的结果如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191225112312.png)

此时在申请一个 4k 的大小，4k 的大小为 24-2 * 1k，因此规范大小为 2，需要在深度为 2 的节点上寻找。从根节点开始，最终的结果如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191225113952.png)

最后再申请一个 2k 的大小，结果如下：

![img](https://markdownpic-1251577930.cos.ap-chengdu.myqcloud.com/20191225114606.png)

### 总结与思考

本文阐述了一种用于管理连续内存申请与分配的算法。在这个基础上，分析了 Netty 在实现中对于该算法的变种。通过这种直观的分析，相信读者对于算法的本质已然掌握，剩余的代码实现自然就是水到渠成。下文，我们将会从代码的角度来分析 Netty 中关于这部分算法的实现。