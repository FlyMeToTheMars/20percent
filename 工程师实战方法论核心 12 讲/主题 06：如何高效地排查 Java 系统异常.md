## 主题 06：如何高效地排查 Java 系统异常

### 1. 引言

作为软件工程师，对于衡量系统性能的常用指标：CPU 使用率、系统负载（Load）、响应时间（RT）、每秒查询率（QPS）、并发数等，应该不陌生。通过这些指标可以量化地评价系统的状态，当系统在运行中出现问题时，这些表征系统性能的指标通常也会出现异常，从而有助于定位问题。更重要的是，大多数情况下，在系统问题爆发之前，某些指标就会显示异常，从而起到预警作用，为排查、解决问题争取时间。理解系统性能指标、掌握排查系统问题的方法，是软件工程师进阶的必备技能。

本文主要内容：

- 详解 CPU 使用率分析及其异常排查方法
- 详解系统负载（Load）分析及其异常排查方法
- 详解内存使用率分析及其异常排查方法

### 2. CPU 使用率分析和异常排查

#### **2.1 预备知识**

**1. CPU 时间片**

CPU 时间片，即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间，使各个程序从表面上看是同时进行的。如果在时间片结束时进程还在运行，则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 当即进行切换，而不会造成 CPU 资源浪费。

目前，计算机搭载的操作系统，如 Windows、Linux 等都是“多任务操作系统”，即可以“同时”执行多个任务，对于用户来说，就是可以“同时”执行多个应用程序，如“同时”看视屏和 QQ 聊天。事实上，这里的“同时”并不是真正意义上的同时。在此，以只有一个单核 CPU 的计算机为例进行说明，由于只有一个 CPU 内核，任何时刻都只能做一件事，那么，如何实现“多任务”呢？一个简明的策略就是引入时间片，每个程序轮流执行，这个时间片很短（Linux 系统为 5ms-800ms，Windows 系统与版本有关，但也是毫秒级），以至于用户无法感知，直观上如同多个程序同时在运行。

**2. CPU 使用率**

CPU 使用率，即运行的程序占用 CPU 时间片的情况，计算公式为：

> CPU 使用率 = CPU 时间片被程序使用的时间/总时间

目前，多任务操作系统对 CPU 都是分时间片使用的：

> 比如 A 进程占用 10ms，然后 B 进程占用 30ms，然后空闲 60ms，再又是 A 进程占 10ms，B 进程占 30ms，空闲 60ms；如果在一段时间内都是如此，那么这段时间内 CPU 的占用率为 40%。

大多数操作系统的 CPU 占用率分为用户态 CPU 使用率和系统态 CPU 使用率。用户态 CPU 使用率是指执行应用程序代码的时间占总 CPU 时间的百分比。相比而言，系统态 CPU 使用率是指应用执行操作系统调用的时间占总 CPU 时间的百分比。系统态的 CPU 使用率高意味着共享资源有竞争或者 I/O 设备之间有大量的交互。

#### **2.2 查看 CPU 使用率**

**1. top 命令**

top 命令是 Linux 下常用的性能分析工具，能够实时显示系统 CPU、内存、Load、进程等信息，类似于 Windows 的任务管理器。如下所示，使用 top 命令执行结果：

![在这里插入图片描述](https://images.gitbook.cn/6d9a1480-6396-11ea-ae70-7703a0bbb1fc)

参数解释：

- 0.7% us：用户空间占用 CPU 百分比；
- 0.3% sy：内核、内核进程占用 CPU 的比率；
- 0.0% ni：如果一些用户进程修改过优先级，这里显示这些进程占用 CPU 时间的比率；
- 48.1% id：空闲 CPU 百分比；
- 0.0% wa：CPU 等待执行 I/O 操作的时间比率，该指标可以用来排查磁盘 I/O 的问题，通常结合 wa 和 id 判断；
- 0.0%hi：硬件 CPU 中断占用百分比；
- 0.0%si：软件 CPU 中断占用百分比；
- 50.9%st：物理机上其它虚拟机占用 CPU 的时间百分比。

#### **2.3 查看 CPU 信息**

命令：

```
cat /proc/cpuinfo
```

执行结果如下，宿主机是 2 个核心。

![在这里插入图片描述](https://images.gitbook.cn/a21857d0-6396-11ea-ae70-7703a0bbb1fc)

参数解释：

- processor：系统中逻辑处理核的编号
- vendor_id：CPU 制造商
- cpu family：CPU 产品系列代号
- model：CPU 属于其系列中的哪一代的代号
- model name：CPU 属于的名字及其编号、标称主频
- stepping：CPU 属于制作更新版本
- cpu MHz：CPU 的实际使用主频
- cache size：CPU 二级缓存大小
- physical id：单个 CPU 的标号
- siblings：单个 CPU 逻辑物理核数
- core id：当前物理核在其所处 CPU 中的编号，这个编号不一定连续
- cpu cores：该逻辑核所处 CPU 的物理核数
- apicid：用来区分不同逻辑核的编号，系统中每个逻辑核的此编号必然不同，此编号不一定连续
- fpu：是否具有浮点运算单元（Floating Point Unit）
- fpu_exception：是否支持浮点计算异常
- cpuid level：执行 cpuid 指令前，eax 寄存器中的值，根据不同的值 cpuid 指令会返回不同的内容
- wp：表明当前 CPU 是否在内核态支持对用户空间的写保护（Write Protection）
- flags：当前 CPU 支持的功能
- bogomips：在系统内核启动时粗略测算的 CPU 速度（Million Instructions Per Second）
- clflush size：每次刷新缓存的大小单位
- cache_alignment：缓存地址对齐单位
- address sizes：可访问地址空间位数
- power management：对能源管理的支持

#### **2.4 定位 CPU 突然飙升的思路**

CPU 突然飙升的常见原因主要有三个，如下所示：

- 宿主机 CPU“超卖”
- 内存问题导致大量 Full GC
- 代码存在死循环

**常见因素一：宿主机 CPU 超卖**

执行 top 命令，结果如下图所示：

![在这里插入图片描述](https://images.gitbook.cn/7d07e7e0-1229-11e9-8fe9-3be93db04177)

top 命令输出的结果信息中，cpu st 的值，即宿主机 CPU 时间片分配给宿主机上其它虚拟机时间占比。如果 st 使用率较大，则 CPU 占用飙升是由于宿主机“超卖”导致，所谓“超卖”是一种通俗的说法，指的是宿主机 CPU 时间片分配给宿主机上其它虚拟机的比重过高（注意：截图中所示的占比并没有达到“超卖”的程度，仅作为示例）。

**常见因素二：内存问题，导致大量 Full GC**

对于 Java 应用而言，Full GC 是一个非常重要的指标，互联网企业通常都有自研的监控预警系统，用于监控 Full GC、堆内存、CPU 占用率等指标。如果企业有自研的监控系统，很容易确认是否为 Full GC 导致 CPU 飙高，如果没有这样的系统，那就需要工程师手动确认了，步骤如下。

**Step1：**通过 top 命令查看当前机器的 CPU 使用情况，如下截图（这里仅作为举例，CPU 使用率并没有飙升）。通过 top 命令输出的结果，可以看到 PID 为 9532 的 Java 进程占用 CPU 最多，可以作为怀疑对象，进一步“侦查”。需要说明的是，这里仅作为举例，截图中占用 CPU 最高的 Java 进程也就 4.0%，在真实的应用场景中，如果是频繁 Full GC 导致的 CPU 飙高，占用率要大得多。

![在这里插入图片描述](https://images.gitbook.cn/8d36d1d0-1229-11e9-8b04-87df50680036)

**Step2：**通过 jstat 命令查看“有嫌疑”的 Java 进程的 GC 情况，常用的命令形式如下：

```
jstat -gcutil 【PID】 1000 100
```

作用为：每 1000ms 打印一次 GC 统计情况，一共打印 100 次。

![在这里插入图片描述](https://images.gitbook.cn/9e0d1f50-1229-11e9-8fe9-3be93db04177)

参数解释：

- S0：Survivor space 0 的利用率
- S1：Survivor space 1 的利用率
- E：Eden space 的利用率
- O：Old space 的利用率
- P：Permanent space 的利用率
- YGC：Young GC 数量
- YGCT：Young GC 时间
- FGC：Full GC 数量
- FGCT：Full GC 时间
- GCT：所有的 GC 时间（YGCT + FGCT）

通过查看 Full GC 和 Young GC 次数，如果发现“嫌疑”进程存在频繁的 Full GC，我们可以进一步通过 Dump 应用的堆内存，对堆内存进行分析，定位异常代码。

**Step3：**通过 Jmap 命令 Dump 有“嫌疑”的 Java 进程（应用程序）的堆快照和对象的统计信息。命令形式如下。

例 1：统计 PID 为 2927 的 Java 程序的对象统计信息。

```Bash
jmap -histo 2927 > a.txt 
```

例 2：统计 PID 为 2927 的 Java 程序的当前堆快照信息。

```Bash
jmap -dump:format=b,file=a.txt 
```

**Step4：**通过 MAT（Memory Analysis Tools）工具对堆快照和对象的统计信息进行分析，定位问题，关于 MAT 工具的使用方法可以查看博客：

> https://blog.csdn.net/jin_kwok/article/details/80326088

**常见因素三：代码存在死循环**

需要先定位到占用大量 CPU 时间片的 Java 线程，然后排查对应线程的代码定位原因，具体步骤如下。

**Step1：**使用 top 命令找到 CPU 占用最高的线程（PID 为进程 ID），看一下是否为 Java 线程。

![在这里插入图片描述](https://images.gitbook.cn/f771f490-11c9-11e9-97a1-4b1ea8726555)

**Step2：**确定有“嫌疑”的 Java 进程后，进一步查看该进程中 CPU 占比靠前的 Java 线程，其中的 PID 为子进程 ID，即 Java 线程 ID。命令如下：

```Bash
top -p 2066 -H
```

说明：

- -H 指显示线程
- -p 是指定进程

从打印的结果可以看出，“嫌疑”进程中 CPU 占比较高的 Java 线程有好几个，通常我们只能逐个排查。

![在这里插入图片描述](https://images.gitbook.cn/2d115f50-11ca-11e9-97a1-4b1ea8726555)

**Step3：**获得 Java 线程 ID 的十六进制值。通过 jstack 命令获取的线程堆栈信息中，线程 ID 是十六进制形式的，因此，为了便于搜索指定线程的相关信息，我们需要先对 top 命令获得的线程 ID 进行预处理，即转化为十六进制形式。命令如下：

```
printf "%x" 3215
```

即打印十进制数 3215 转化为十六进制的值。

![在这里插入图片描述](https://images.gitbook.cn/6e094cc0-11ca-11e9-9e80-bfe1824b4f06)

**Step4：**通过 jstack 命令获取占用资源异常的线程栈。

可暂时保存到一个文件中查看 jstack 3215 > jstack.3215.log，在生成的文件中，通过搜索线程ID的十六进制值找到对应的信息。为了快速定位问题，通常，我们会直接通过命令过滤出需要的信息，命令形式如下：

```Bash
jstack 2066 | grep c8f
```

![在这里插入图片描述](https://images.gitbook.cn/919f4130-11ca-11e9-8a5e-2dea41779bd6)

**注意：**

- jstack 的对象是 Java 进程的 PID，而不是 Java 线程的 PID；
- 尽量不要使用 jstack -F 命令，可能会导致应用的所有线程挂起。

**关于 jstack 命令的补充**

jstack 命令格式：

```Bash
jstack [ option ] pid
```

option 参数说明：

- -F：`jstack [-l] pid` 无法响应时，强制打印堆栈
- -l：l 长列表，打印关于锁的附加信息，例如属于 java.util.concurrent 的 ownable synchronizers 列表
- -m：混合模式输出（包括 Java 和本地 C/C++ 片段）堆栈
- pid：Java 应用程序的进程号

`jstack pid` 只能看到指定线程的堆栈信息。如果想看到关于线程中的锁的附加信息，可以加一个 `-l` 参数，命令形式为：

```Bash
jstack -l pid
```

上面方法用于进程正常情况下的堆栈打印，某些异常场景下，`jstack -l` 命令可能没有响应，根据提示：

```
［The -F option can be used when the target process is not responding］
```

加上参数 `-F`。

```Bash
jstack -F PID > jstack.PID.txt
```

### 3. 系统负载（Load）分析和异常排查

#### **3.1 预备知识：系统负载**

系统负载（Load）是指在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。

当 CPU 完全空闲的时候，平均负荷为 0；当 CPU 工作量饱和的时候，平均负荷为 1。举个例子，如果 CPU 每分钟最多处理 100 个进程，那么，系统负荷 0.2 就意味着 CPU 在这 1 分钟里只处理 20 个进程；系统负荷 1.0，意味着 CPU 在这 1 分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程以外还有 70 个进程正排队等着 CPU 处理。

**1. 系统负载（Load）与系统的繁忙程度**

在此，以单核 CPU 为例，解读系统负载（Load）与系统的繁忙程度的关系，注意关键词——单核 CPU。

- Load<1：没有等待
- Load==1：系统已无额外的资源跑更多的进程了
- Load>1：进程都堵着等待资源

**需要警惕的**

- Load < 0.7 时：系统很闲，要考虑多部署一些服务
- 0.7 < Load < 1 时：系统状态不错
- Load == 1 时：系统马上要处理不多来了，赶紧找一下原因
- Load > 5 时：系统已经非常繁忙了

**不同 Load 值说明的问题**

- 1 分钟 Load>5，5 分钟 Load<1，15 分钟 Load<1 短期内繁忙，中长期空闲，初步判断是一个抖动或者是拥塞前兆
- 1 分钟 Load>5，5 分钟 Load>1，15 分钟 Load<1 短期内繁忙，中期内紧张，很可能是一个拥塞的开始
- 1 分钟 Load>5，5 分钟 Load>5，15 分钟 Load>5 短中长期都繁忙，系统正在拥塞
- 1 分钟 Load<1，5 分钟 Load>1，15 分钟 Load>5 短期内空闲，中长期繁忙，不用紧张，系统拥塞正在好转

**2. 多核或者单核多处理器**

**单核多 CPU**

如果计算机有 2 个单核 CPU，负载能力又是什么情况呢？2 个 CPU，意味着电脑的处理能力增加一倍，能够同时处理的进程数量也增加一倍。如果用大桥来类比，两个 CPU 就意味着大桥有两根车道了，通车能力翻倍了。所以，2 个 CPU 表明系统负荷可以达到 2.0，此时每个 CPU 都达到 100% 的工作量。推广开来，N 个单核 CPU 的计算机，可接受的系统负荷最大为：N*1.0。

**多核 CPU**

目前，计算机所使用的 CPU 基本都是多核的，这类 CPU 被称为多核 CPU。在系统负载方面，多核 CPU 与多 CPU 效果类似，所以考虑系统负载时，必须考虑计算机有几个 CPU、每个 CPU 有几个核心。然后，把系统负载除以总的核心数，只要每个核心的负荷不超过 1.0，就表明计算机正常运行。对于具有 N 个 CPU，每个 CPU 具有 M 个核心的计算机，其系统负载最大为：NM1.0。

#### **3.2 CPU 使用率与负载（Load）的区别**

这里要区别 CPU 负载和 CPU 利用率，它们是不同的两个概念。

**CPU 利用率：**显示的是程序在运行期间实时占用的 CPU 百分比，这是对一个时间段内 CPU 使用状况的统计，通过这个指标可以看出在某一个时间段内 CPU 被占用的情况，如果被占用时间很高，那么就需要考虑 CPU 是否已经处于超负荷运作。

**CPU 负载：**显示的是在一段时间内 CPU 正在处理以及等待 CPU 处理的进程数之和的统计信息，也就是 CPU 使用队列的长度的统计信息。

简单理解，一个是 CPU 的实时使用情况，一个是 CPU 的当前以及未来一段时间的使用情况。

#### **3.3 查看系统负载**

**1. uptime 命令**

![在这里插入图片描述](https://images.gitbook.cn/fea222f0-11cc-11e9-b709-dd47b21aef83)

关键参数解释：

- `load average: 0.61, 0.57, 0.57` 就是负载信息，分别表示 1 分钟、5 分钟、15 分钟内系统的平均负荷。

其它参数解释：

- `11:46:19`：系统当前时间
- `up 6 days, 18:54`：系统开机到现在经过了 6 天

**2. w 命令**

![在这里插入图片描述](https://images.gitbook.cn/2a95d0a0-11cd-11e9-97a1-4b1ea8726555)

关键参数解释：

- `load average: 0.74, 0.61, 0.59` 就是负载信息，分别表示 1 分钟、5 分钟、15 分钟内系统的平均负荷。

其它参数解释：

- USER：登录的用户名；
- TTY：登录后系统分配的终端号；
- FROM：远程主机名，即从哪儿登录来的；
- LOGIN@：何时登录；
- IDLE：空闲了多长时间，表示用户闲置的时间。这是一个计时器，一旦用户执行任何操作，该计时器便会被重置；
- JCPU：和该终端（tty）连接的所有进程占用的时间，这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间；
- PCPU：指当前进程（即在 WHAT 项中显示的进程）所占用的时间；
- WHAT：当前正在运行进程的命令行。

**3. top 命令**

![在这里插入图片描述](https://images.gitbook.cn/64c43960-11cd-11e9-8a5e-2dea41779bd6)

`load average: 0.25, 0.33, 0.38` 就是负载信息，分别表示 1 分钟、5 分钟、15 分钟内系统的平均负荷。

#### **3.4 计算机正常负载范围**

以单核 CPU 为例，经验法则是这样的：

1. 当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化；
2. 当系统负荷持续大于 1.0，你必须动手寻找解决办法，把这个值降下来；
3. 当系统负荷达到 5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。

#### **3.5 CPU 使用率低而负载高**

主要原因是等待磁盘 I/O 的进程过多，导致进程队列长度过大，但是 CPU 运行的进程却很少，这样就导致负载过大，但 CPU 使用率低。

**1. 常见场景**

- 磁盘读写请求过多就会导致大量 I/O 等待；
- MySQL 中存在没有索引的语句或存在死锁；
- 外接硬盘故障，常见有挂载了 NFS，但是 NFS Server 故障。

**2. 场景分析**

**场景 1：磁盘读写请求过多就会导致大量 I/O 等待**

CPU 的工作效率要高于磁盘，而进程在 CPU 上面运行需要访问磁盘文件，这个时候 CPU 会向内核发起调用文件的请求，让内核去磁盘取文件，这个时候会切换到其他进程或者空闲，这个任务就会转换为不可中断睡眠状态。当这种读写请求过多就会导致不可中断睡眠状态的进程过多，从而导致负载高，CPU 低的情况。

**场景 2：MySQL 中存在没有索引的语句或存在死锁**

MySQL 的数据是存储在硬盘中，如果需进行 SQL 查询，要先把数据从磁盘加载到内存中。当在数据特别大的时候，如果执行的 SQL 语句没有索引，就会造成扫描表的行数过大导致 I/O 阻塞，或者是语句中存在死锁，也会造成 I/O 阻塞，从而导致不可中断睡眠进程过多，导致负载过大。

**场景 3：外接硬盘故障，常见有挂载了 NFS，但是 NFS Server 故障**

假如系统挂载了外接硬盘，如 NFS 共享存储，经常会有大量的读写请求去访问 NFS 存储的文件，如果这个时候 NFS Server 故障，那么就会导致进程读写请求一直获取不到资源，从而进程一直是不可中断状态，造成负载很高。

### 4. 内存使用率异常

#### **4.1 预备知识：内存**

内存是计算机中重要的部件之一，它是与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。一旦内存使用出现异常，对程序会产生重大影响。内存也被称为内存储器，其作用是用于暂时存放 CPU 中的运算数据，以及与硬盘等外部存储器交换的数据。

**1. 物理内存**

物理内存指通过物理内存条而获得的内存空间，即随机存取存储器（Random Access Memory，RAM），是与 CPU 直接交换数据的内部存储器，也叫主存（内存）。

**2. 虚拟内存**

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换（也就是说，当物理内存不足时，可能会借用磁盘空间来充当内存使用）。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。

**3. Swap 分区**

Swap 分区（即交换区）在系统的物理内存不够用的时候（没有了 buffers 和 cache 时），可以临时存放使用率不高的内存分页，把这一部分物理内存释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到 Swap 分区中，等到那些程序要运行时，再从 Swap 分区中恢复保存的数据到内存中。

对于线上的应用服务器，通常都不设置 Swap，而是通过限定 JVM 内存小于物理内存的方式控制内存大小。

#### **4.2 查看内存使用情况**

**1. free 命令**

![在这里插入图片描述](https://images.gitbook.cn/ca20b110-1229-11e9-8fe9-3be93db04177)

参数解释：

- Mem 是内存的使用情况；
- -/+ buffers/cache 是物理内存的缓存统计情况；
- Swap 是交换空间的使用情况。

列（Mem 行）：

- total 4194304，表示物理内存总大小；
- used 4172552，表示总计分配给缓存（包含 buffers 与cache ）使用的数量，其中可能部分缓存并未实际使用；
- free 21752，表示未被分配的内存；
- shared 0，共享内存，一般系统不会用到；
- buffers 0，系统分配但未被使用的 buffers 数量；
- cached 1773124，系统分配但未被使用的 cache 数量。

列（-/+ buffers/cache 行）：

- Used 2399428，表示实际使用的 buffers 与cache 总量，也是实际使用的内存总量；
- Free 1794876，未被使用的 buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。

数据间的关系：

- used（-/+ buffers/cache） = used（Mem） – cached（Mem） – buffers（Mem）；
- free（-/+ buffers/cache） = free（Mem） + cached （Mem）+ buffers（Mem）；
- used（mem）为系统已分配内存大小；
- free（-/+ buffers/cache）为系统实际可用内存大小；

buffers 和 cache 的区别：

```Bash
A buffer is something that has yet to be “written” to disk.
A cache is something that has been “read” from the disk and stored for later use.
```

cache 是为了弥补高速设备和低速设备的鸿沟而引入的中间层，最终起到“加快访问速度”的作用；buffer 的主要目的进行流量整理，把突发的“大数量小规模的 I/O”整理成平稳的“小数量较大规模的 I/O”，以减少响应次数（比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写）。

**2. top 命令**

示例如下：

![在这里插入图片描述](https://images.gitbook.cn/b9ec5370-122a-11e9-91d0-5b59a999b543)

> 系统上实际可用内存大小 = free + buffers + cached = 1,809,148k
>
> 系统已经分配的内存大小 = used = 4,159,876k

#### **4.3 内存占用飙高及常见定位方法**

**1. 常见原因**

- 内存溢出
- 内存泄露
- 堆外内存使用不当

**2. 原因排查—内存溢出**

**内存溢出：**指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于 OLD 段或 Perm 段垃圾回收后，仍然无内存空间容纳新的 Java 对象的情况。

**堆内存溢出（outOfMemoryError：java heap space）**

在 JVM 规范中，堆中的内存是用来生成对象实例和数组的。如果细分，堆内存还可以分为年轻代和年老代，年轻代包括一个 Eden 区和两个 Survivor 区。当生成新对象时，内存的申请过程如下：

1. JVM 先尝试在 Eden 区分配新建对象所需的内存；
2. 如果内存大小足够，申请结束，否则下一步；
3. JVM 启动 youngGC，试图将 Eden 区中不活跃的对象释放掉，释放后若 Eden 空间仍然不足以放入新对象，则试图将部分 Eden 中活跃对象放入 Survivor 区；
4. Survivor 区被用来作为 Eden 及 Old 的中间交换区域，当 Old 区空间足够时，Survivor 区的对象会被移到 Old 区，否则会被保留在 Survivor 区；
5. 当 Old 区空间不够时，JVM 会在 Old 区进行 Full GC；
6. Full GC 后，若 Survivor 及 Old 区仍然无法存放从 Eden 复制过来的部分对象，导致 JVM 无法在 Eden 区为新对象创建内存区域，则出现”out of memory 错误”：`outOfMemoryError: java heap space`。

**方法区内存溢出（outOfMemoryError：permgem space）**

在 JVM 规范中，方法区主要存放的是类信息、常量、静态变量等。所以如果程序加载的类过多，或者使用反射、cglib 等这种动态代理生成类的技术，就可能导致该区发生内存溢出，一般该区发生内存溢出时的错误信息为：`outOfMemoryError:permgem space`。

**线程栈溢出（java.lang.StackOverflowError）**

线程栈时线程独有的一块内存结构，所以线程栈发生问题必定是某个线程运行时产生的错误。一般线程栈溢出是由于递归太深或方法调用层级过多导致的。发生栈溢出的错误信息为：java.lang.StackOverflowError。

**3. 原因排查—内存泄露**

内存泄露是指程序中动态分配内存给一些临时对象，代码段运行结束后，这些对象已经没有被使用，但由于 GC Roots 可达，没有被 GC 回收，始终占用内存。简单来说即被分配的对象无用但可达，这种问题一般是代码设计存在缺陷导致的。常用的定位步骤如下（结合例子说明）：

**Step1：**使用 top 命令，查看占用内存较高的进程 ID。

![在这里插入图片描述](https://images.gitbook.cn/18affd00-11cf-11e9-b709-dd47b21aef83)

发现 PID 为 2544 的进程占用内存 58.2%，而且是一个 Java 进程，基本断定是程序问题。

**Step2：**使用 jmap 查看内存情况，并分析是否存在内存泄露。

```Bash
jmap -heap 5442：查看java 堆（heap）使用情况
jmap -histo 5442：查看堆内存(histogram)中的对象数量及大小
jmap -histo:live 5442：JVM会先触发gc，然后再统计信息
jmap -dump:format=b,file=heapDump 5442：将内存使用的详细情况输出到文件
```

得到堆 dump 文件后，使用 MAT（Memory Analyzer Tool）或者 Zprofile 进行对象分析。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露。排查创建该对象的代码，进行修改。

**常见的代码内存泄露的原因有：**

- 长生命周期的对象持有短生命周期对象的引用 ;
- 修改 hashse t中对象的参数值，且参数是计算哈希值的字段 ;
- 机器的连接数和关闭时间设置。

**4. 原因排查—堆外内存使用不当**

**什么是堆外内存**

和堆内内存相对应，堆外内存就是把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。关于对外内存，感兴趣的读者可以查看文章《[作为 Java 开发者，你需要了解的堆外内存知识](https://gitbook.cn/gitchat/activity/5af07387585c260a21a32b97)》。

**堆外内存的优点**

减少了垃圾回收，因为垃圾回收会暂停其他的工作；加快了复制的速度，堆内在 flush 到远程时，会先复制到直接内存，然后再发送，而堆外内存相当于省略掉了复制这个步骤。

**堆外内存的缺点**

堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了 JVM 管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难。

**堆外内存使用场景**

NIO 引入了一种基于通道与缓冲区的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 java.nio.DirectByteBuffer 对象作为这块堆外内存的引用进行操作。

**异常解决**

DirectMemory 容量可通过 `-XX:MaxDirectMemorySize` 指定，如果不指定，则默认与 Java 堆的最大值（-Xmx 指定）一样。

### 5. 总结

本文介绍了 Java 系统异常排查的“三板斧”，即 CPU、Load 和内存，其中涉及大量操作系统相关的知识，理解起来会有一定难度，但这正是工程师进阶的必经之路。

衡量一个 Java 系统的运行状态有很多指标，本文介绍的三个指标是其中最重要、最常见的，通过这些指标可以量化地评价系统的状态。在阿里内部，这三个指标是监控大盘默认的必选项，当系统出现问题时，这些指标通常会显示异常，监控系统会向相关责任人发送预警信息，从而为排查、解决问题争取时间。

需要特别说明的是，本文介绍的是 CPU、Load 和内存相关的**常见异常及排查方法**，旨在带领读者学习排查异常的方法和思路，掌握异常排查的方法论，而并非“系统异常宝典”。在工程师的职业生涯中势必会遇到常见问题之外的问题，此时便需要工程师能够理清思路，有步骤地、高效地排查，因此，掌握方法论比单纯地了解一个知识点更为重要。同时，对于工程师，每遇到一个新问题都是一次成长，将这些问题、场景和解决方法分类记录，日积月累，“宝典”自成。