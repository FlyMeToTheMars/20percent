# 分布式系统中服务降级策略探究

### 一、前言

在分布式系统架构中多个系统之间通常是通过远程 RPC 调用进行通信，也就是 A 系统调用 B 系统服务，B 系统调用 C 系统的服务。当尾部应用 C 发生故障而系统 B 没有服务降级时候可能会导致 B，甚至系统 A 瘫痪，这种现象被称为雪崩现象。所以在系统设计时候要使用一定的降级策略，来保证当服务提供方服务不可用时候，服务调用方可以切换到降级后的策略进行执行。

本 Chat 我们主要围绕下面主题展开：

- Dubbo 中服务降级策略的使用；
- Dubbo 中服务降级策略的实现原理；
- Hystrix 中基于自反馈，调节熔断状态的算法原理讲解；
- Hystrix 熔断机制的使用（有 Demo）；
- RXJava 基础知识讲解（Hystrix 的熔断机制使用到了这些知识）；
- Hystrix 中如何使用 RXJava 实现统计数据收集；
- Dubbo 的服务降级策略与 Hystrix 的熔断机制的简单对比。

### 二、Dubbo 中服务降级策略的使用

> 注：本文当讲解到服务注册中心时候，是指 使用 ZooKeeper 搭建的服务注册中心。

Dubbo 提供了一些服务降级措施，当服务提供端某一个非关键的服务出错时候，可以手动对消费端的调用进行降级，这样服务消费端就避免了在去调用出错的服务提供端，从而加重服务提供者的负担。

下面我们看下 Dubbo 提供的两种服务降级策略如何使用：

- **`force:return` 策略：**当服务调用方设置某个接口的降级策略为这种方式时候，服务调用方在调用该接口服务时候会直接在客户端内返回设置的 mock 值，而不会在通过远程调用方式调用服务提供者。具体是使用下面代码进行设置：

```Java
        // (1)获取服务注册中心工厂
        RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class)
                .getAdaptiveExtension();
        // (2)根据zk地址，获取具体的zk注册中心的客户端实例
        Registry registry2 = registryFactory.getRegistry(URL.valueOf("zookeeper://127.0.0.1:2181"));
        // (3)注册降级方案到zk
        registry2.register(URL.valueOf(
                "override://0.0.0.0/com.test.UserServiceBo?category=configurators&dynamic=false&application=dubboConsumer&"
                        + "mock=force:return+null&group=dubbo&version=1.0.0"));
```

其中 mock=force:return+null 表示服务调用方调用该服务的方法时候都直接返回 mock 的 null 值，而不发起远程调用。需要注意url里面要指明是对那个接口的那个分组的那个版本的服务进行降级，另外 category 必须为 configurators，application 为你的服务调用方的应用名称，也就是 ApplicationConfig 的 name 值。`override://0.0.0.0/` 标示该降级策略对所有的服务消费者生效。

执行上面代码，会保存该设置到 ZK，ZK 会持久化存放该设置，设置完后，可以在管理控制台查看： ![121.jpg](http://upload-images.jianshu.io/upload_images/5879294-ddee55b87a218a29.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](http://upload-images.jianshu.io/upload_images/5879294-1071191969b59b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可知降级策略已经可以看到了，这时候你在服务调用方调用该接口的服务，就会直接返回 null 了。当然你也可以不使用代码来设置，而是使用管理控制台手动录入（管理控制台的搭建可以参考 Chat：[使用 Dubbo 搭建一个简单的分布式系统](http://gitbook.cn/gitchat/activity/5aa9e5b3ac2d91025be482b1)） 管理控制台手动录入后，管理控制台会注册设置的降级策略到 ZK。

- **`fail:return` 策略：**表示服务调用方调用服务提供方服务失败后再返回 null 值，并不会抛出异常，与 `force：return` 区别是前者如果调用服务提供者成功，则返回正常的结果，如果调用失败了则才返回 mock 的值。需要注意的是并不是调用一次失败后就直接返回 null，具体调用几次失败后在返回 null 和设置的集群容错方式有关，比如集群容错方式配置的为 `Failover Cluster` 并且 `retries="2"` 则说明调用服务提供方三次都失败后才返回 mock 的值 （具体集群容错详细介绍可以参考：[高性能 RPC 框架 Dubbo 从入门到深入](http://gitbook.cn/gitchat/column/5adda21279e8c577efc8fbdf)） 具体设置方式和上代码类似，只是把 force 改为了 fail。

### 三、Dubbo 中服务降级策略的实现原理

#### 3.1 概述

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/5edc00806512bf67d98c3eae7d5e5cef.png) 当使用上节代码方式设置接口 com.test.UserServiceBo 的服务降级策略后，就会在 ZK 服务器的 com.test.UserServiceBo service 的子树中 type 为 configurators 下面写入具体的降级策略，同理也可以使用 admin 手动配置服务降级策略。

管理控制台 admin 启动后，会从 ZK 把 com.test.UserServiceBo service 的子树中 Providers（服务提供者列表），Routes（路由信息），Configurators（服务降级策略等信息），Consumers(服务消费者列表）的信息获取过来，然后使用 web 页面显示出来。

当服务消费者启动时候会去 ZK 订阅 com.test.UserServiceBo service 的子树中的信息，比如 Providers（服务提供者列表），Routes（路由信息），Configurators（服务降级策略等信息），当服务消费者具体发起远程调用时候会根据路由规则和负载均衡算法从服务提供者列表选择一个 IP 作为调用目标，然后具体发起远程调用前，会看是否设置了 `force:return` 降级策略，如果设置了则直接返回 mock 值，并不发起远程调用；

否者发起远程调用，如果远程调用结果 OK，则直接返回远程调用返回的结果。如果远程调用失败，则看当前的集群从容策略是什么，如果是失败重试，则还要看通过 retries 设置的重试次数是多少，如果重试次数为 2 次，则会在调用失败后在进行重试两次调用，如果其中一次成功了，则直接返回结果。如果两次都失败了，则看当前是否设置了 `fail:return` 的降级策略，如果设置了，则直接返回 mock 值，否者返回调用远程服务失败的具体原因。

#### 3.2 服务消费端订阅降级策略并保存

首先为了能够很好的切入主题，我们先看看服务消费端的启动流程如下： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/79beb834f05817c51993e1ee552179ba.png) 如上图是服务消费端启动时序图，这里我们只关注步骤（10），因为步骤（10）具体是消费端从 ZK 获取设置的降级策略。下面我们来看看 RegistryDirectory 的 subscribe 的执行时序图： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0540964ce504124933c3e87a2a530835.png) 如上时序图，消费端从 ZK 订阅服务信息，ZK 在准备好数据后会异步把数据发送给注册的 listener，而 RegistryDirectory 本身就是一个 listener，所以 zkclient 会把服务数据传递给 RegistryDirectory 的 notify 方法，下面我们来看看 notify 方法代码：

```Java
 public synchronized void notify(List<URL> urls) {
         //1)存放服务提供者列表
        List<URL> invokerUrls = new ArrayList<URL>();
        //2)存放设置的路由规则
        List<URL> routerUrls = new ArrayList<URL>();
        //3)存放设置的降级策略等
        List<URL> configuratorUrls = new ArrayList<URL>();
        //4)设置不同类别的信息
        for (URL url : urls) {
            String protocol = url.getProtocol();
            String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);
            if (Constants.ROUTERS_CATEGORY.equals(category)
                    || Constants.ROUTE_PROTOCOL.equals(protocol)) {
                routerUrls.add(url);

            //4.1) CONFIGURATORS_CATEGORY = "configurators";OVERRIDE_PROTOCOL = "override"
            } else if (Constants.CONFIGURATORS_CATEGORY.equals(category)
                    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) {
                configuratorUrls.add(url);
            } else if (Constants.PROVIDERS_CATEGORY.equals(category)) {
                invokerUrls.add(url);
            } else {
                logger.warn("Unsupported category " + category + " in notified url: " + url + " from registry " + getUrl().getAddress() + " to consumer " + NetUtils.getLocalHost());
            }
        }
        //5) 解析服务降级策略等到configurators
        if (configuratorUrls != null && configuratorUrls.size() > 0) {
            this.configurators = toConfigurators(configuratorUrls);
        }
        //6)解析路由规则到 routers
        if (routerUrls != null && routerUrls.size() > 0) {
            List<Router> routers = toRouters(routerUrls);
            if (routers != null) { // null - do nothing
                setRouters(routers);
            }
        }
        List<Configurator> localConfigurators = this.configurators; // local reference
        //7)具体这里把降级策略拼接到url
        this.overrideDirectoryUrl = directoryUrl;
        if (localConfigurators != null && localConfigurators.size() > 0) {
            for (Configurator configurator : localConfigurators) {
                this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);
            }
        }
        //8) 刷新本地服务提供者列表providers
        refreshInvoker(invokerUrls);
    }
```

如上代码(4.1) 把类别为 configurators 并且协议为 override 的 url 放入到了 configuratorUrls 里面，代码（5） 解析服务降级策略 configuratorUrls 保存到 configurators。代码（7）是具体把降级策略拼接到url里面并存放到变量 overrideDirectoryUrl，代码（8）是根据新的服务提供者列表刷新本地保存的列表。

其中上面例子中 overrideDirectoryUrl 的内容如下：

```
zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=dubboConsumer&dubbo=2.0.1&group=dubbo&interface=com.test.UserServiceBo&methods=testPojo,sayHello2,sayHello&mock=force:return+null&pid=25650&register.ip=30.8.60.119&revision=1.0.0&side=consumer&timeout=3000&timestamp=1525942604236&version=1.0.0
```

可知设置的降级策略 mock=force:return+null 被拼接到了 url 里面。

#### 3.3 服务消费端使用降级策略

服务消费端具体使用降级策略是在 MockClusterInvoker 类的 invoker 方法里面，下面我们来看下其代码：

```java
 public Result invoke(Invocation invocation) throws RpcException {
        Result result = null;
        //1）看url里面是否有mock字段
        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();
        //2)如果没有，或者值为默认的false，则说明没有设置降级策略
        if (value.length() == 0 || value.equalsIgnoreCase("false")) {
            //2.1）no mock, 正常调用
            result = this.invoker.invoke(invocation);
         //3)设置了force:return降级策略
        } else if (value.startsWith("force")) {
            if (logger.isWarnEnabled()) {
                logger.info("force-mock: " + invocation.getMethodName() + " force-mock enabled , url : " + directory.getUrl());
            }
            //3.1）force:direct mock
            result = doMockInvoke(invocation, null);
        } else {
            //4）设置fail-mock
            try {
                result = this.invoker.invoke(invocation);//4.1)
            } catch (RpcException e) {
                if (e.isBiz()) {//4.2)
                    throw e;
                } else {
                    if (logger.isWarnEnabled()) {
                        logger.info("fail-mock: " + invocation.getMethodName() + " fail-mock enabled , url : " + directory.getUrl(), e);
                    }
                    result = doMockInvoke(invocation, e);//4.3)
                }
            }
        }
        return result;
    }
```

如上代码其中 directory.getUrl() 获取的就是上节我们讲解的 overrideDirectoryUrl，代码（1）看该 url 里面是否含有 mock 的值，如果没有或者有但是值为 false，则说明没有设置降解策略，则执行代码（2.1）也就是正常发起远程调用。

如果 url 里面含有 mock 字段，并且其值以 force 开头，则说明设置了 `force:return` 降级策略，则直接调用 doMockInvoke 方法，返回 mock 值，而不发起远程调用。

如果 url 里面含有 mock 字段，并且其值以 fail 开头，则说明设置了 `fail:return` 降级策略，则先发起远程调用，如果远程调用成功，则直接返回远程返回的结果，否者执行代码（4.3）直接返回 mock 的值。

### 四、Hystrix 中基于自反馈调节熔断状态的算法原理

我们可以把熔断器想象为一个保险丝，在电路系统中，一般在所有的家电系统连接外部供电的线路中间都会加一个保险丝，当外部电压过高，达到保险丝的熔点时候，保险丝就会被熔断，从而可以切断家电系统与外部电路的联通，进而保障家电系统不会因为电压过高而损坏。

Hystrix 提供的熔断器就有类似功能，当在一定时间段内服务调用方调用服务提供方的服务的次数达到设定的阈值，并且出错的次数也达到设置的出错阈值，就会进行服务降级，让服务调用方执行本地设置的降级策略，而不再发起远程调用。但是 Hystrix 提供的熔断器具有自我反馈，自我恢复的功能，Hystrix 会根据调用接口的情况，让熔断器在 closed、open、half-open 三种状态之间自动切换。

- open 状态说明打开熔断，也就是服务调用方执行本地降级策略，不进行远程调用。
- closed 状态说明关闭了熔断，这时候服务调用方直接发起远程调用。
- half-open 状态，则是一个中间状态，用来尝试恢复熔断器状态为 closed 或者 open 状态。

三种状态的转换：

- closed->open：正常情况下熔断器为 closed 状态，当访问同一个接口次数超过设定阈值并且错误比例超过设置错误阈值时候，就会打开熔断机制，这时候熔断器状态从 closed->open。
- open->half-open：当服务接口对应的熔断器状态为 open 状态时候，所有服务调用方调用该服务方法时候都是执行本地降级方法，那么什么时候才会恢复到远程调用那？Hystrix 提供了一种测试策略，也就是设置了一个时间窗口，从熔断器状态变为 open 状态开始的一个时间窗口内，调用该服务接口时候都委托服务降级方法进行执行。如果时间超过了时间窗口，则超过时间窗口后的第一个请求时候会把熔断状态从 open->half-open，这时候服务调用方调用服务接口时候，就可以发起远程调用而不再使用本地降级接口，如果发起远程调用还是失败，则重新设置熔断器状态为 open 状态，从新记录时间窗口开始时间；如果发起远程调用成功，则重新设置熔断器状态为从 half-open->closed 状态。需要注意超过时间窗口后只有一个请求可以发起远程调用，其它请求还是执行降级操作。

那么有一个问题，用来判断熔断器从 closed->open 转换的数据是哪里来的那？其实这个是 HystrixCommandMetrics 对象来做的，该对象用来存在 HystrixCommand 的一些指标数据，比如接口调用次数，调用接口失败的次数等等，后面我们会讲解。

### 五、Hystrix 熔断机制的使用

服务熔断一般是在服务调用方进行，使用 Hystrix 的熔断机制，需要让调用方服务类继承 HystrixCommand 类。下面我们来看个例子，先看在使用熔断机制前例子。

#### 5.1 服务提供方代码

```Java
public class TestProviderApi {

    public static void main(String[] arg) throws InterruptedException {
        //(1) 创建要提供的服务的实例
        UserServiceBo userService = new UserServiceImpl();
        //(2) 配置应用信息
        ApplicationConfig application = new ApplicationConfig();
        application.setName("dubboProvider");

        //（3）配置服务注册中心地址
        RegistryConfig registry = new RegistryConfig();
        registry.setAddress("127.0.0.1:2181");
        registry.setProtocol("zookeeper");

        //(4)使用的传输协议
        ProtocolConfig protocol = new ProtocolConfig();
        protocol.setName("dubbo");
        protocol.setPort(20880);

        //（5）配置从服务注册中心查找监控中心地址
        MonitorConfig monitorConfig = new MonitorConfig();
        monitorConfig.setProtocol("registry");

        //(6)创建服务提供者配置类
        ServiceConfig<UserServiceBo> service = new ServiceConfig<UserServiceBo>();
        service.setApplication(application);
        service.setMonitor(monitorConfig);
        service.setRegistry(registry); 
        service.setProtocol(protocol); 

        //(6.1)interface + version+group
        service.setInterface(UserServiceBo.class);
        service.setRef(userService);
        service.setVersion("1.0.0");
        service.setGroup("dubbo");
        //(6.2)服务提供端超时时间
        service.setTimeout(5000);
        //(6.3)导出服务
        service.export();

        //挂起当前线程
        Thread.currentThread().join();
    }
```

上面代码启动一个服务提供者进程，UserServiceBo 服务会被注册到服务注册中心（ZooKeeper）上，这里需要留意下服务端超时时间为 5s。

其中 UserServiceImpl 的代码如下：

```Java
public class UserServiceImpl implements UserServiceBo{

    @Override
    public String sayHello(String name) {
        //让当前当前线程休眠4s
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return name; 
    }
}
```

需要注意服务提供端，sayHello 的执行需要耗时 4s。

#### 5.2 服务消费端正常情况下调用

服务消费端在不使用熔断机制情况下正常调用代码如下：

```Java
public class TestConsumerApi {
    public static void main(String[] args) throws InterruptedException {
        // (1) 配置应用信息
        ApplicationConfig application = new ApplicationConfig();
        application.setName("dubboConsumer");

        // （2）配置服务注册中心地址
        RegistryConfig registry = new RegistryConfig();
        registry.setAddress("127.0.0.1:2181");
        registry.setProtocol("zookeeper");

        // （3）配置从服务注册中心查找监控中心地址
        MonitorConfig monitorConfig = new MonitorConfig();
        monitorConfig.setProtocol("registry");

        // (4)创建服务消费者配置类
        ReferenceConfig<UserServiceBo> reference = new ReferenceConfig<UserServiceBo>(); //
        reference.setApplication(application);
        reference.setRegistry(registry);
        reference.setMonitor(monitorConfig);

        // (4.1)interface+version+group
        reference.setInterface(UserServiceBo.class);
        reference.setVersion("1.0.0");
        reference.setGroup("dubbo");
        // (4.2)设置客户端超时时间
        reference.setTimeout(2000);

        // (4.4)获取远程服务代理类
        UserServiceBo userService = reference.get();

        // (4.5)具体调用远程方法执行
        System.out.println(userService.sayHello("hello jiaduo"));


    }
}
```

代码很简单，需要注意的是，这里客户端超时时间设置为了 2s。

- 实验一：首先启动 ZK，然后启动服务提供端代码注册服务到 ZK，然后运行本节消费端代码后发现会抛出如下异常：

```java
Caused by: com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 
2018-05-10 22:33:34.749, end time: 2018-05-10 22:33:36.753, client elapsed: 1 ms, server elapsed: 2003 ms, 
timeout: 2000 ms, request: Request [id=2, version=2.0.0, twoway=true, event=false, broken=false, 
data=RpcInvocation [methodName=sayHello, parameterTypes=[class java.lang.String], arguments=[hello jiaduo], 
attachments={path=com.test.UserServiceBo, interface=com.test.UserServiceBo, group=dubbo, timeout=2000, 
```

也就是客户端超时了，这是因为服务提供方服务代码里面耗时了 4s，而客户端超时时间设置为了 2s，所以客户端等待超时，抛出了异常。

- 试验二：首先启动 ZK，然后不启动服务提供者，直接运行消费者代码，出现下面异常：

```java
Exception in thread "main" java.lang.IllegalStateException: Failed to check the status of the service com.test.UserServiceBo. No provider available for the service dubbo/com.test.UserServiceBo:1.0.0 from the url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?
application=dubboConsumer&dubbo=2.0.1&group=dubbo&interface=com.test.UserServiceBo&methods=testPojo,sayHello2,sayHello&pid=2454&register.ip=192.168.1.102&revision=1.0.0&side=consumer&timeout=2000&timestamp=1525963248695&version=1.0.0 to the consumer 192.168.1.102 use dubbo version 2.0.1at 
com.alibaba.dubbo.config.ReferenceConfig.createProxy(ReferenceConfig.java:422)
```

也就是找到不服务提供者。

#### 5.3 服务消费端使用熔断机制

```java
public class TestConsumerApiUseHystrix {
    public static void main(String[] args) throws InterruptedException {
        // (1) 配置应用信息
        ApplicationConfig application = new ApplicationConfig();
        application.setName("dubboConsumer");

        // （2）配置服务注册中心地址
        RegistryConfig registry = new RegistryConfig();
        registry.setAddress("127.0.0.1:2181");
        registry.setProtocol("zookeeper");

        // （3）配置从服务注册中心查找监控中心地址
        MonitorConfig monitorConfig = new MonitorConfig();
        monitorConfig.setProtocol("registry");

        // (4)创建服务消费者配置类
        ReferenceConfig<UserServiceBo> reference = new ReferenceConfig<UserServiceBo>(); //
        reference.setApplication(application);
        reference.setRegistry(registry);
        reference.setMonitor(monitorConfig);

        // (4.1)interface+version+group
        reference.setInterface(UserServiceBo.class);
        reference.setVersion("1.0.0");
        reference.setGroup("dubbo");
        // (4.2)设置客户端超时时间
        reference.setTimeout(2000);

        // (4.4)获取远程服务代理类
        UserServiceBo userService = reference.get();

        // (4.5)具体调用远程方法执行
        try {
            System.out.println(new CommandHelloFailure("TestGROUP", userService).execute());
        } catch (Exception e) {
            System.out.println(e.getLocalizedMessage());
        }
    }
}
```

如上代码具体是（4.5）修改了，改为new CommandHelloFailure后构造函数里面传递 userService，然后执行execute() 方法，其中 CommandHelloFailure 的定义如下：

```Java
public class CommandHelloFailure extends HystrixCommand<String> {

    private final String name;
    private UserServiceBo userService;

    public CommandHelloFailure(String name,UserServiceBo userService) {
        super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("ExampleFallbackGroup"))
        .andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(3000)));
        this.name = name;   
        this.userService =  userService;
    }   

    @Override
    protected String run() {
        //此处模拟调用远程RPC
        return userService.sayHello("hello jiaduo");
    }

    @Override
    protected String getFallback() {
        return "Hello Failure " + name + "!";
    }

}
```

可知 CommandHelloFailure 继承了 HystrixCommand，这是实现熔断必须的，然后重写了 run 方法，run 方法内具体调用我们的 userService.sayHello 方法，重写了 getFallback 方法，该方法是服务降级方法。

当服务提供方服务正常时候当我们执行代码（4.5）的时候实际执行的是 CommandHelloFailure 的 run 方法，run 方法内具体调用了 userService.sayHello，当服务提供方的 userService 服务正常时候，run 方法直接返回服务提供方的结果，当服务提供方服务不正常时候，调用方会使用降级方法 getFallback 返回调用方。

- 试验一：启动 ZK，然后启动服务提供者，然后启动上面服务消费者代码，运行结果如下： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/61cb34166dfbb56980911a0ffe59a3cb.png) 可知服务降级策略被执行了
- 试验二：这时候启动 ZK，然后关闭服务提供者，然后运行上面代码，结果输出：

```Java
Exception in thread "main" java.lang.IllegalStateException: Failed to check the status of the service com.test.UserServiceBo. No provider available for the service dubbo/com.test.UserServiceBo:1.0.0 from the url zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=dubboConsumer&dubbo=2.0.1&group=dubbo&interface=com.test.UserServiceBo&methods=testPojo,sayHello2,sayHello&pid=2656&register.ip=192.168.1.102&revision=1.0.0&side=consumer&timeout=2000&timestamp=1525963830043&version=1.0.0 to the consumer 192.168.1.102 use dubbo version 2.0.1
    at com.alibaba.dubbo.config.ReferenceConfig.createProxy(ReferenceConfig.java:422)
```

抛出了服务不存在异常，你可能会奇怪，为啥降级服务没生效那，不应该返回 getFallback 方法执行内容？是的，正常下是应该返回 getFallback 的结果，但是 dubbo 在启动时候会检查依赖的服务是否存在，如果不存在则会阻止服务的启动，所以我们在代码（4.5） 前面添加 `reference.setCheck(false);` 关闭启动时候自动检查，然后在运行结果如下： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0959fd69b3d0918e8f0842c0f8076872.png) 可知服务降级生效了。

### 六、RXJava 基础知识讲解

Hystrix 的熔断机制中统计数据收集使用到了 RXJava 的知识。

#### 6.1 基础概念

- Observer（观察者）：类似观察者模式中的观察者。
- Observable（被观察对象）：类似观察者模式中的，被观察对象，
- Subject（主题）：主题在 RXJava 中是指一种桥接或者代理，由于其实现了 Observer 接口，继承了 Observable 类，所以这个主题即可用充当观察者，也可以充当被观察的对象。作为观察者时候，它可以订阅一个或者多个被观察的对象，作为被观察的对象时候，它会在发射元素时候通知订阅该观察对象的观察者。

#### 6.2 PublishSubject 主题

当一个 Observer（观察者）订阅了该主题后，就会接受到订阅后主题发射的元素，但是订阅前主题发射的元素接受不到。

下面通过一个简单例子来说明 PublishSubject 的使用

```Java
public class PublishSubjectTest {

    public static void test() {
               //(1)
        PublishSubject<String> publishSubject = PublishSubject.create();
        publishSubject.onNext("begin sub");//(2)
               //(3)
        publishSubject.subscribe(new Observer<String>() {

            public void onCompleted() {

            }

            public void onError(Throwable e) {

            }
                       //(3.1)
            public void onNext(String t) {
                System.out.println(t);

            }
        });

                //(4)
        publishSubject.onNext("sub after hello");
        publishSubject.onNext("sub after world");

    }

    public static void main(String[] args) {

        test();
    }
}
```

如上代码（1）使用 PublishSubject.create() 创建了一个主题，然后紧接着代码（2）调用主题的 onNext 发射了一个元素“begin sub”。然后代码（3）创建了一个 Observer（观察者）订阅了该主题，然后代码（4）调用主题的onNext方法连续发射了“sub after hello”和“sub after world”两个元素，运行上面代码输出结果：

```Java
sub after hello
sub after world
```

可知在代码（3）观察者订阅前主题发射的元素，观察者并没有收到，只收到了订阅后，主题发射的元素。

#### 6.3 SerializedSubject 主题

使用 PublishSubject.create() 创建的主题，在多线程下并发调用主题的 onNext 方法时候，并不能保证最终订阅者接受到的元素是有序的，这时候需要使用 SerializedSubject 对其进行包装，SerializedSubject 内部通过使用队列来缓存多线程调用主题 publishSubject 主题调用 onNext 方法发射的元素，然后顺序从队列移除元素调用 PublishSubject 的 onNext 方法。

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e47ce9295bacf57c4e13a379bbc62798.png)

比如上面的例子转换为序列主题使用下面方式：

```Java
        Subject<String,String> serializedSubject = new SerializedSubject<String,String>(publishSubject);
```

#### 6.4 元素转换

转换 Observable（被观察对象）发射的元素，从一个中形式到另外一种形式。

##### **6.4.1 window 操作**

按照时间窗口或者元素个数，把一个观察者对象，拆分为多个观察者对象，也就是拆分后原来观察者对象发射出来的每个元素都是一个观察者对象。

- 按照时间窗口聚合元素：

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/edf148ccde615e55637e58c4f6f2d2fb.png)

下面我们从一个 demo 来具体理解：

```Java
//(1
static Observable<Long> sender = Observable.interval(1, TimeUnit.SECONDS);
//(2)
public static void timeWidnow(){
                //(2.1)
        sender.window(5,TimeUnit.SECONDS,3).subscribe(new Observer() {

            int i = 0;
            @Override
            public void onCompleted() {
                // TODO Auto-generated method stub

            }

            @Override
            public void onError(Throwable e) {
                // TODO Auto-generated method stub

            }
                       //(2.2)
            @Override
            public void onNext(Object t) {
                ++i;
                System.out.println(i + " " + "sub" + " " + new Date().getSeconds()); // 将接收到来自sender的问候"Hi，Weavey！"
                                //2.2.1
                Observable<Long> obj = (Observable<Long>) t;
                obj.subscribe(new Observer() {

                    @Override
                    public void onCompleted() {
                        // TODO Auto-generated method stub

                    }

                    @Override
                    public void onError(Throwable e) {
                        // TODO Auto-generated method stub

                    }
                                       //2.2.1.1
                    @Override
                    public void onNext(Object t) {
                        System.out.println(i + " " + t + " " + new Date().getSeconds()); // 将接收到来自sender的问候"Hi，Weavey！"

                    }

                });
            }

        });
    }
    public static void main(String[] args) throws InterruptedException {
        timeWidnow();
}
```

代码（1）创建了一个被观察者对象，sender 这个被观察者对象会持续间隔 1s 发射一个整数元素（0，1，2，3...），也就是如果一个观察者订阅了该对象，则该观察者会每隔 1s 收到一个元素.

代码（2）调用 `sender.window(5,TimeUnit.SECONDS,3)` 意味着将 sender 被观察者对象使用时间窗口拆分，时间单位为 5s，每个拆分出来的子被观察者对象元素最多为 3，比如之前 sender 发射元素为0，1，2，3，4，5，6，7，8，9，10。那么执行`sender.window(5,TimeUnit.SECONDS,3)`后间隔第一个 5s 返回一个包含 0，1，2 的被观察者对象，第二个 5s 返回的可能是包含 3，4，5 的被观察者对象...

代码（2）紧接着创建了一个观察者对象并订阅了 `sender.window(5,TimeUnit.SECONDS,3)` 返回的被观察者对象，可知代码（2.2） 每次回收到一个被观察者对象，比如第一个 5s 返回一个包含 0，1，2 的被观察者对象，第二个 5s 返回包含 3，4，5 的被观察者对象... ，然后代码（2.2.1）创建了一个新的观察者对象用来订阅子被观察者对象。

运行上面代码输出如下：

```java
1 sub 10
1 0 11
1 1 12
1 2 13
2 sub 14
2 3 14
3 sub 15
3 4 15
3 5 16
3 6 17
4 sub 18
4 7 18
4 8 19
5 sub 20
5 9 20
5 10 21
5 11 22
6 sub 23
6 12 23
6 13 24
7 sub 25
...
```

也就是 window 函数会根据时间窗口把要发射的元素聚合起来产生新的被观察者对象，聚合后发射的元素其实是被观察对象，而不是普通的元素。

- 按照元素个数聚合元素，示意图如下 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/df8f19ada960d9c6bdff3af2fbc19717.png) 下面通过例子来说明:

```java
public static void numWindow() {
        sender.window(2,3).subscribe(new Observer() {

            int i = 0;

            @Override
            public void onCompleted() {
                // TODO Auto-generated method stub

            }

            @Override
            public void onError(Throwable e) {
                // TODO Auto-generated method stub

            }

            @Override
            public void onNext(Object t) {
                ++i;
                System.out.println(i + " " + "sub" + " " + new Date().getSeconds()); // 将接收到来自sender的问候"Hi，Weavey！"
                Observable<Long> obj = (Observable<Long>) t;
                obj.subscribe(new Observer() {

                    @Override
                    public void onCompleted() {
                        // TODO Auto-generated method stub

                    }

                    @Override
                    public void onError(Throwable e) {
                        // TODO Auto-generated method stub

                    }

                    @Override
                    public void onNext(Object t) {
                        System.out.println(i + " " + t + " " + new Date().getSeconds()); // 将接收到来自sender的问候"Hi，Weavey！"

                    }

                });
            }

        });
```

把上面 timeWidnow 换成 numWindow 运行结果：

```Java
1 sub 6
1 0 6
1 1 7
2 sub 9
2 3 9
2 4 10
3 sub 12
3 6 12
3 7 13
4 sub 15
4 9 15
4 10 16
5 sub 18
5 12 18
5 13 19
6 sub 21
6 15 21
...
```

可知每个子被观察者对象里面还有两个元素，并且第二列都是跳过一个元素，这是因为 window 的滴三个参数为 3，而窗口元素个数为 2，所以会跳过窗口元素后边的一个元素，结合图示意图来理解。

##### **6.4.2 flatMap 操作**

该操作的作用是转换发射的元素的类型，如下官方示意图：

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6c8e12c3813313399cc5f48f5a75eceb.png)

下面通过一个例子来具体理解：

```Java
    static Observable<Long> sender = Observable.interval(1, TimeUnit.SECONDS).flatMap(new Func1<Long, Observable<? extends Long>>() {

        @Override
        public Observable<? extends Long> call(Long t) {
            return Observable.just(t*2);
        }
    });

    public static void normalSub() {
        sender.subscribe(new Observer() {

            int i = 0;

            @Override
            public void onCompleted() {
                // TODO Auto-generated method stub

            }

            @Override
            public void onError(Throwable e) {
                // TODO Auto-generated method stub

            }

            @Override
            public void onNext(Object t) {
                ++i;
                System.out.println(i + " " + t); // 将接收到来自sender的问候"Hi，Weavey！"

            }

        });
    }

    public static void main(String[] args) throws InterruptedException {
        normalSub();

    }
```

如上代码 `Observable.interval(1, TimeUnit.SECONDS)` 的作用之前已经说过了是间隔 1s 发射元素，比如发射 0，1，2，3，4...。然后调用了 flatMap 方法，该方法传递了一个函数，这个函数的call方法具体转换被观察者要发送的元素内容，这里是把原来的元素值都乘以 2。转换后会返回一个新的被观察者对象，其内部元素值为原来的值乘 2。运行上面代码结果如下：

```Java
1 0
2 2
3 4
4 6
5 8
6 10
7 12
8 14
9 16
...
```

可知第二列的值为原来值 *2；

##### **6.4.3 StartWith 操作**

在被观察者对象发射元素前，插入一些元素，作为发射元素，官方示意图： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/43d54636e1744d7143fba5c165ed8bcc.png)

下面看个实例：

```java
 //别观察对象，元素为1，2，3，4，5
    static Observable sender = Observable.just(1, 2, 3, 4, 5);


    public static void testStartWith() {
        List<Long> list = new ArrayList<>();
        list.add(111L);
        list.add(112L);
        list.add(113L);
        list.add(114L);

        sender.startWith(list).subscribe(new Observer() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Object t) {
                System.out.println(t); 

            }

        });

    }

    public static void main(String[] args) throws InterruptedException {
        testStartWith();
    }
```

运行上面代码输出：

```Java
111
112
113
114
1
2
3
4
5
```

##### **6.4.4 reduce 操作**

对被观察者要发送的所有元素顺序施加一个运算符，然后发射计算后的一个结果元素，官方示意图： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c68e599dc31487f0e615c2e9620a5fb2.png)

下面看个例子：

```Java
// 被观察对象，元素为1，2，3，4，5
    static Observable sender = Observable.just(1, 2, 3, 4, 5);

    public static void testReduce() {

        sender.reduce(new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }
        }).subscribe(new Observer() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Object t) {
                System.out.println(t);

            }

        });

    }

    public static void main(String[] args) throws InterruptedException {
        testReduce();
    }
```

运行上面代码，输出：

```java
15
```

##### **6.4.5 scan 操作**

类似 Reduce 操作，被观察者要发送的所有元素顺序施加一个运算符，但是不是发射计算后的一个结果元素，而是使用顺序计算值替代当前元素，官方示意图：

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3bf4ae9956819f6f5d3af89d6aed2a55.png)

一个例子：

```java
    // 被观察对象，元素为1，2，3，4，5
    static Observable sender = Observable.just(1, 2, 3, 4, 5);

    public static void testScan() {

        sender.scan(new Func2<Integer, Integer, Integer>() {

            @Override
            public Integer call(Integer t1, Integer t2) {
                return t1 + t2;
            }
        }).subscribe(new Observer() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {

            }

            @Override
            public void onNext(Object t) {
                System.out.println(t);

            }

        });

    }

    public static void main(String[] args) throws InterruptedException {
        testScan();
    }
```

运行上面代码，输出：

```Java
1
3
6
10
15
```

本节介绍了 RXJava 中一些常用的操作，为后面讲解 Hystrix 实现数据收集做准备，RXJava 还是比较牛逼的，童鞋们下去可以自己去全面学习下。

### 七、Hystrix 中熔断器状态转换源码分析

#### 7.1 概述

首先从整体看看下 Hystrix 的执行流程： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a0a18ed013750ad90ac588a9f450b8a2.png)

如上时序图当执行 HystrixCommand 的 execute 方法后，最后会调用 AbstractCommand 的 applyHystrixSemantics 方法，该方法添加了熔断的语义，首先会调用 HystrixCircuitBreakerImpl 的 attemptExecution 方法看当前熔断器的状态，如果当前熔断器状态为 closed 或者为 open 但是是超过时间窗口的第一个请求则返回 true，否者返回 false。

如果步骤（5）返回 false，说明当前熔断器是打开状态，这时候就会执行降级 getFallback 方法，而不执行 run 方法内代码。

如果步骤（5）返回 true，说明当前熔断器是闭合状态，这时候执行 run 方法内代码，如果执行 run 方法抛出异常或者执行超时，也会执行降级 getFallback 方法。

#### 7.2 如何判断是否需要熔断

首先我们看下 HystrixCircuitBreakerImpl 的 attemptExecution 方法，HystrixCircuitBreakerImpl 类是修改熔断器状态的核心类：

```Java
public boolean attemptExecution() {
    //(1)如果配置了熔断器一直是打开状态，则一直返回false
    if (properties.circuitBreakerForceOpen().get()) {
        return false;
    }

   //(2)如果配置熔断器一直是闭合状态，则一直返回true
    if (properties.circuitBreakerForceClosed().get()) {
        return true;
    }
    //（3）等于-1说明目前是closed状态
    if (circuitOpened.get() == -1) {
        return true;
    } else {
        //(4)从熔断器开始为open状态，到现在是否过了一个时间窗口，
        if (isAfterSleepWindow()) {
            if (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) {
                //（4.1）仅仅是超过时间窗口后第一个请求返回true，其他返回false
                return true;
            } else {//(4.2)
                return false;
            }
        } else {//(5)如果否，直接返回false
            return false;
        }
    }
}
```

如上代码（1）如果配置了熔断器一直是打开状态，则一直返回 false，具体是在创建 HystrixCommand 对象时候设置，如下代码： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/488e587112932568ea964602771dc0f9.png)

如上代码（2）如果配置熔断器一直是闭合状态，则一直返回 true，具体是在创建 HystrixCommand 对象时候设置，如下代码： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/448e3791b6df9f3b08625709bed4e95c.png)

如上代码（3）circuitOpened 的值等于 -1 说明目前是 closed 状态，circuitOpened 是一个原子变量默认是 -1，当熔断器状态从 closed->open 时候，会修改其值为当前时间毫秒数，当熔断器状态从其他状态变为 closed 时候值会重置为 -1。

如上代码（4）判断从熔断器开始为 open 状态，到现在是否过了一个时间窗口，如果不是，则直接返回 false，如果是则看当前状态是不是 open，如果是则说明这是超过时间窗口后第一个请求，则把熔断器状态修改为 half-open 状态，返回 true，当变为 half-open 状态后，其它请求还是返回 false。

#### 7.3 何时设置熔断状态

通过上面我们谈了如何判断一个请求是否应该执行降级策略，下面我们来看看如何设置熔断器状态的。

在分析熔断原理时候我们说过，如果远程调用成功则会设置熔断器状态为 closed，执行失败设置若你果断器状态为 open，下面我们来看看具体哪里执行的？

下面我们看步骤（8）的代码：

```Java
 private Observable<R> executeCommandAndObserve(final AbstractCommand<R> _cmd) {
        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();
        ...
        //（7） 发射元素时候的回调
        final Action1<R> markEmits = new Action1<R>() {
            @Override
            public void call(R r) {
                if (shouldOutputOnNextEvents()) {
                    executionResult = executionResult.addEvent(HystrixEventType.EMIT);
                    eventNotifier.markEvent(HystrixEventType.EMIT, commandKey);
                }
                if (commandIsScalar()) {
                    long latency = System.currentTimeMillis() - executionResult.getStartTimestamp();
                    eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);
                    executionResult = executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);
                    eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());
                    circuitBreaker.markSuccess();//7.1执行熔断器的markSuccess方法
                }
            }
        };

      ...
        //（8）fallback回调
        final Func1<Throwable, Observable<R>> handleFallback = new Func1<Throwable, Observable<R>>() {
            @Override
            public Observable<R> call(Throwable t) {
                circuitBreaker.markNonSuccess();//(8.1)执行失败后要调用熔断器的markNonSuccess方法
                ...
            }
        };

       ...

        return execution.doOnNext(markEmits)
                .doOnCompleted(markOnCompleted)
                .onErrorResumeNext(handleFallback)
                .doOnEach(setRequestContext);
    }
```

其中代码（7.1）当 RXJava 的 Observable 发射出元素后会调用熔断器 HystrixCircuitBreakerImpl 的 markSuccess 方法，内容如下：

```Java
        public void markSuccess() {
           //设置熔断器状态从half-open到closed
            if (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) {
                //This thread wins the race to close the circuit - it resets the stream to start it over from 0
                metrics.resetStream();
                Subscription previousSubscription = activeSubscription.get();
                if (previousSubscription != null) {
                    previousSubscription.unsubscribe();
                }
                Subscription newSubscription = subscribeToStream();
                activeSubscription.set(newSubscription);
                circuitOpened.set(-1L);//重置为-1
            }
        }
```

代码(8.1) 执行失败后要调用熔断器的 markNonSuccess 方法：

```Java
        public void markNonSuccess() {
                  //设置熔断器状态从half-open到open
            if (status.compareAndSet(Status.HALF_OPEN, Status.OPEN)) {
                //This thread wins the race to re-open the circuit - it resets the start time for the sleep window
                circuitOpened.set(System.currentTimeMillis());//设置为当前时间
            }
        }
```

然后还有一个状态转换就是 closed->open 的转换，这个涉及到数据收集还是比较麻烦的，首先抛开 RXJava，纯碎看代码是哪里进行设置的，翻看 HystrixCircuitBreakerImpl 的构造函数：

```Java
        protected HystrixCircuitBreakerImpl(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, final HystrixCommandProperties properties, HystrixCommandMetrics metrics) {
            this.properties = properties;
            this.metrics = metrics;

            //调用了subscribeToStream方法
            Subscription s = subscribeToStream();
            activeSubscription.set(s);
        }
```

subscribeToStream 方法代码如下：

```Java
        private Subscription subscribeToStream() {

            return metrics.getHealthCountsStream()
                    .observe()
                    .subscribe(new Subscriber<HealthCounts>() {
                        @Override
                        public void onCompleted() {

                        }

                        @Override
                        public void onError(Throwable e) {

                        }

                        @Override
                        public void onNext(HealthCounts hc) {
                            // 当前接口请求次数是否小于statisticalWindowVolumeThreshold
                            if (hc.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold().get()) {

                            } else {//当前请求错误率是否小于设置的错误率
                                if (hc.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage().get()) {

                                } else {
                                    // 设置熔断状态从closed->open
                                    if (status.compareAndSet(Status.CLOSED, Status.OPEN)) {
                                        circuitOpened.set(System.currentTimeMillis());
                                    }
                                }
                            }
                        }
                    });
        }
```

如上代码当当前接口请求的错误率超过了指定的阈值时候会设置熔断器状态从 closed->open 的转换。 下面一节我们来看如何使用 RAJAVA 实现统计数据的收集。

### 八、如何使用 RXJava 实现统计数据收集

#### 8.1 被观察者对象创建与操作转换

首先来看下 HystrixCommand 启动时候如何使用 RXJava 逐级创建被观察者对象，以及使用大量 RXJava 操作对被观察者对象进行转换，时序图如下：

![HystrixCommand.jpg](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/03bf29b741a64da112f65c1afc98cb0d.jpg)

如上图，其中步骤（1）（2），由于 HystrixCommand 继承自 AbstractCommand，所以创建 HystrixCommand 对象时候会首先调用 AbstractCommand 的构造函数。

AbstractCommand 的构造函数里面会调用步骤（3）创建 HystrixCommandMetrics 对象，该对象用来存在 HystrixCommand 的一些指标数据。在创建 HystrixCommandMetrics 的对象时候，其构造函数里面又执行了步骤（5）创建了 HealthCountsStream 对象实例，该类继承自 BucketedRollingCounterStream，后者又继承自 BucketedCounterStream。

在创建 HealthCountsStream 对象时候，其构造函数内部执行步骤（7）创建了 HystrixCommandCompletionStream 对象，该对象构造函数代码如下：

```Java
    HystrixCommandCompletionStream(final HystrixCommandKey commandKey) {
        this.commandKey = commandKey;

        this.writeOnlySubject = new SerializedSubject<HystrixCommandCompletion, HystrixCommandCompletion>(PublishSubject.<HystrixCommandCompletion>create());
        this.readOnlyStream = writeOnlySubject.share();
    }
```

如上代码首先使用 PublishSubject。`<HystrixCommandCompletion>create()` 创建了一个PublishSubject 类型，元素类型为 `HystrixCommandCompletion` 的主题，然后转换该主题为 `SerializedSubject` 主题，该主题在并发下可以保证订阅者接受元素的有序性，序列主题保存到了 `writeOnlySubject` 变量里面，另外创建一个只读的主题放到了 `readOnlyStream` 变量。

然后执行步骤（10）执行 HealthCountsStream 的父类 BucketedRollingCounterStream 的构造函数：

```Java
 protected BucketedRollingCounterStream(HystrixEventStream<Event> stream, final int numBuckets, int bucketSizeInMs,
                                           final Func2<Bucket, Event, Bucket> appendRawEventToBucket,
                                           final Func2<Output, Bucket, Output> reduceBucket) {
       //(I)执行父类构造函数
        super(stream, numBuckets, bucketSizeInMs, appendRawEventToBucket);
   ...
    }
```

如代码(I) BucketedRollingCounterStream 构造函数内又先调用 BucketedRollingCounterStream 的父类 BucketedCounterStream 的构造函数：

```Java
 protected BucketedCounterStream(final HystrixEventStream<Event> inputEventStream, final int numBuckets, final int bucketSizeInMs,
                                    final Func2<Bucket, Event, Bucket> appendRawEventToBucket) {
        this.numBuckets = numBuckets;
        this.reduceBucketToSummary = new Func1<Observable<Event>, Observable<Bucket>>() {
            @Override
            public Observable<Bucket> call(Observable<Event> eventBucket) {
                return eventBucket.reduce(getEmptyBucketSummary(), appendRawEventToBucket);
            }
        };

        final List<Bucket> emptyEventCountsToStart = new ArrayList<Bucket>();
        for (int i = 0; i < numBuckets; i++) {
            emptyEventCountsToStart.add(getEmptyBucketSummary());
        }

        this.bucketedStream = Observable.defer(new Func0<Observable<Bucket>>() {
            @Override
            public Observable<Bucket> call() {
                return inputEventStream
                        .observe()//(II)
                        .window(bucketSizeInMs, TimeUnit.MILLISECONDS) //bucket it by the counter window so we can emit to the next operator in time chunks, not on every OnNext
                        .flatMap(reduceBucketToSummary)  //(III)              //for a given bucket, turn it into a long array containing counts of event types
                        .startWith(emptyEventCountsToStart);           //start it with empty arrays to make consumer logic as generic as possible (windows are always full)
            }
        });
    }
```

如上代码其中 inputEventStream 就是时序图步骤（7）创建的 HystrixCommandCompletionStream 对象，其内部维护了创建的 SerializedSubject 主题，所以步骤(II) inputEventStream .observe() 返回的是 readOnlyStream 被观察对象。然后使用 window 函数的时间窗口默认对 500ms 时间段里面元素进行聚合，也就是间隔 500ms 发射一次聚合内容，然后 flatMap 转换聚合内容，具体是使用下面函数： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9fee88114bc5c434a07909a7ac20a238.png) 其中 appendRawEventToBucket 为: ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/34026d7cf63cd37bb7429985b60b7617.png)

总结下，这里 bucket 就是一个 long 型数组，数组长度为 HystrixEventType.values().length，HystrixEventType 里面封装了 hystrix 里面的所有事件： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3da768322cf3439485be3853bd20ba68.png)

bucket 这个数组的下标就是具体事件类型，下标对应的值是该类型事件发生的次数，所以这里代码（III）flatMap 的作用是对时间窗口里面的所有的 bucket 对象使用 Reduce 进行累加，累加后每个时间窗口内的多个 bucket 元素，就变成了一个 bucket 元素了，也就是把一个时间窗口内的 long 数组对应下标对应的值相加得到一个 long 数组。最后 bucketedStream 里面的元素就是按照时间窗口聚合后的 long 数组元素，比如第一个元素是 500ms 内所有事件发生次数的 long 数组，第二个元素是下一个 500ms 内所有事件发送次数的 long 数组…。到这里 BucketedCounterStream 的构造函数完毕，然后执行其子类 BucketedRollingCounterStream 的构造函数：

```java
protected BucketedRollingCounterStream(HystrixEventStream<Event> stream, final int numBuckets, int bucketSizeInMs,
                                           final Func2<Bucket, Event, Bucket> appendRawEventToBucket,
                                           final Func2<Output, Bucket, Output> reduceBucket) {
        super(stream, numBuckets, bucketSizeInMs, appendRawEventToBucket);
        Func1<Observable<Bucket>, Observable<Output>> reduceWindowToSummary = new Func1<Observable<Bucket>, Observable<Output>>() {
            @Override
            public Observable<Output> call(Observable<Bucket> window) {
                return window.scan(getEmptyOutputValue(), reduceBucket).skip(numBuckets);
            }
        };
        this.sourceStream = bucketedStream      //(IIII)
                .window(numBuckets, 1)          //emit overlapping windows of buckets
                .flatMap(reduceWindowToSummary) //convert a window of bucket-summaries into a single summary
                .doOnSubscribe(new Action0() {
                    @Override
                    public void call() {
                        isSourceCurrentlySubscribed.set(true);
                    }
                })
                .doOnUnsubscribe(new Action0() {
                    @Override
                    public void call() {
                        isSourceCurrentlySubscribed.set(false);
                    }
                })
                .share()                        //multiple subscribers should get same data
                .onBackpressureDrop();          //if there are slow consumers, data should not buffer
    }
```

其中 bucketedStream 就是 BucketedCounterStream 里面讲解的 bucketedStream，z 这里首先使用 window 函数，比如 numBuckets 为 20，意思是说最多每个窗口有 20 个 bucket，相邻窗口会在相邻点共同含有一个重叠的 bucket。然后执行 flatmap 方法： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/216bcd2a4830ab684ac01d96f2fce15c.png) 使用 scan 方法对每个窗口元素进行累加后替换，其中聚合函数 reduceBucket 为： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c736e0bec75514ac368acc7d6d4db233.png) HealthCounts的plus 函数为：

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dc94746d0a6f812c2f20b064d33d0f72.png)

最后调用 skip 方法，跳过 numBuckets 个元素，也就是只返回了全部元素累加后的一个 long 数组，这个数组里面保存了所有事件发生次数，到这里创建了 sourceStream 被观察者对象。

这里在看下熔断器里面如何获取到上面经过转换后的被观察者对象 sourceStream，打开 HystrixCircuitBreakerImpl 的构造函数：

```java
protected HystrixCircuitBreakerImpl(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, final HystrixCommandProperties properties, HystrixCommandMetrics metrics) {
    //订阅主题
    Subscription s = subscribeToStream();
    activeSubscription.set(s);
}

private Subscription subscribeToStream() {
    //(A)获取metrics里面的健康检查流
    return metrics.getHealthCountsStream()
            .observe()//(B)
            .subscribe(new Subscriber<HealthCounts>() {
                @Override
                public void onCompleted() {

                }

                @Override
                public void onError(Throwable e) {

                }
                //(C)
                @Override
                public void onNext(HealthCounts hc) {
                    // check if we are past the statisticalWindowVolumeThreshold
                    if (hc.getTotalRequests() < properties.circuitBreakerRequestVolumeThreshold().get()) {

                    } else {
                        if (hc.getErrorPercentage() < properties.circuitBreakerErrorThresholdPercentage().get()) {

                        } else {
                            // our failure rate is too high, we need to set the state to OPEN
                            if (status.compareAndSet(Status.CLOSED, Status.OPEN)) {
                                circuitOpened.set(System.currentTimeMillis());
                            }
                        }
                    }
                }
            });
}
```

如上代码(A) 获取 HystrixCommandMetrics 中的 healthCountsStream 对象，然后代码(B) 调用 healthCountsStream 的 observe() 方法获取到被观察者对象 sourceStream。

然后当执行 HystrixCommand 的 execute 操作时候会调用 HystrixCommandMetrics 的 markCommandDone 方法把具体的事件通过调用 HystrixCommandCompletionStream 对象的 write 方法使用内部维护的 SerializedSubject 主题的 onNext 方法发射出去，然后经过上节讲的一些列的操作转换后会被熔断器 HystrixCircuitBreakerImpl 中订阅对象的 onNext 方法接受，后者使用这些统计数据来判断是否进行熔断操作。

### 九、Dubbo 的服务降级策略与 Hystrix 的熔断机制的简单对比

Dubbo 提供的降级策略比较简单，Dubbo 的降级可以通过代码设置或者通过管理控制台进行设置，并且一旦设置为了降级，那么所有消费者调用降级接口时候都是用本地 mock 值，并没有自动恢复策略，并且必须让管理员手动进行降级或者取消降级。而 Hystrix 除了提供 Dubbo 类似的降级策略外，还提供了自适应的降级恢复策略，当调用服务异常次数超过指定阈值后会自动进行降级，并且降级后不是一直都是用降级方案，它可以在降级后时间窗口过后再次进行尝试远程调用，如果目前服务已经 OK，那么会自动关闭降级，这种自反馈的降级，降级恢复策略在整个过程中都自动完成的，不需要人工干涉。

### 十、总结

本节首先讲解了目前使用比较广泛的 Dubbo 框架中服务降级策略的使用，以及原理实现。然后讲解了目前作为服务降级比较有名的 Hystrix 组件的使用，以及原理实现，Hystrix 的自动熔断与恢复的原理还是比较简单的，但是其用来判断是否该熔断的数据统计的收集使用 RXJava 来实现的，实现代码还是比较复杂的，本文只是蜻蜓点水的从整体讲解了如何使用 RXJava 来实现数据收集，希望读者私下能翻看源码，进入深入研究。