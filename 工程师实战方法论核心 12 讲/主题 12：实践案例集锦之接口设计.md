## 主题 12：实践案例集锦之接口设计

### 1. 引言

API 是模块或者子系统之间交互的桥梁，好的系统架构离不开好的 API 设计。在《主题 1：如何设计一个好的 API》一文中，笔者解读了什么样的 API 设计是好的设计，本文作为 API 设计话题的延续，将介绍如何在设计中实践之前介绍的设计方法论。

> 成功的系统不是有一些特别闪光的地方，而是设计时点点滴滴的努力积累起来的。

API 设计面临的挑战千差万别，没有一种普适性的原则可以适用于所有场景，因此，即便是久经考验的设计原则和最佳实践，本身也一定有适应的场景和不适应的场景。鉴于此，笔者在介绍一些设计原则的同时也会分析这些原则在什么场景下适用，以便读者在实践中可以有针对性地采取例外的策略。

### 2. 设计 API 的基本原则

#### **2.1 思维模型清晰**

很多工程师有一个误解——API 设计的关键在于让客户端与服务端进行良好地交互。这种认识忽略了一个重要的因素——人（包括 API 的设计者、维护者、使用者），事实上，API 设计的关键应是让 API 相关的工程师群体在 API 生命周期内良好地进行互动。一个 API 如何被使用，以及 API 本身如何被维护，依赖于维护者和使用者对该 API 有清晰的、一致的认识，而要达到这一目标，就需要设计者提供一个清晰的、易于理解的模型。

如下图所示，从 API 设计者的角度，他设计了一个模型 A；而从使用者的角度，他看到和理解的模型可能会退化成模型 B，如果这个模型比较复杂，在实际使用过程中可能进一步退化成 C；对于维护者来说，也存在相似的问题。

![在这里插入图片描述](https://images.gitbook.cn/2ae18180-8175-11ea-8186-75c206477f1e)

一个好的 API 设计必须提供清晰的思维模型，即让维护者和使用者能够很容易地理解设计者要传达的模型，从而促进理解、调试、测试、代码扩展和系统维护性的提升。

好的例子：

> 很多基础设施领域的 API 都提供了非常好的正面的设计典型，如后面会重点提到的 File API，就提供了非常清晰明了的思维模型。

不好的例子：

> String 是软件中常见的类型，但是在一些 String 类库的实现中，我们会看到设计者为了某些方便，提供了以数组方式访问字符串的 API，这类 API 容易让使用者形成“字符串=array of chars”的模型印象，而这样的印象在一些特殊场景实际是不成立的（例如 Unicode 编码等形态）。

#### **2.2 繁简有度**

在实践中，系统随着需求增加和频繁迭代而不断地演化，由此往往引发设计过于复杂的问题，即在 API 中引入了过多的实现细节；同时也有不少的例子是过度简化引起的，如一些不该被合并的改变合并了。过度简化或复杂的设计都是不合理的。

在实践中，API 设计得过于复杂的问题一般见于初入职场的工程；而过于简化的问题则往往是由工程师“炫技”引起，如下例子：

> 将一个用户的账户模型的 account balance 和 transactions 简化为用 transactions 一个模型来表达，逻辑在于 account balance 可以由历史的 transactions 累计得到。但是这样过于简化的模型设计带来了很多的问题，尤其在引入分期付款、预约交易等概念之后，暴露了很多复杂的逻辑给一些只需要获取简单信息的客户端（如计算这个用户是否还有足够的余额交易，变得和很多业务逻辑耦合），属于典型的模型过度简化带来的设计复杂度上升的案例。

#### **2.3 容许多个实现**

在讨论 API 设计时，常常被提到的原则是**解耦合原则（亦称松耦合原则）**，但是，在实践中这一原则通常难以衡量。相较于解耦合原则，“**容许多个实现**”这一原则的评估具有更强的可操作性：如果一个 API 可以支持多个完全不同的实现，那么这个 API 应已具备足够好的抽象，一般也不会出现与外部系统耦合过紧的问题。某种程度上，“容许多个实现”这一原则在评估“耦合度”方面更本质一些。

举个例子，比如我们已经有一个简单的 API，如下所示：

```Java
QueryOrderResponse queryOrder(QueryOrderRequest request)
```

但是有些场景需要确保读取到最新的订单数据（不接受缓存），几经思量，工程师决定增加一个字段 useCache 来决策如何处理这样的请求， API 设计了如下：

```Java
QueryOrderResponse queryOrder(QueryOrderRequest request, boolean useCache)
  //或者将参数 useCache 包装在 QueryOrderRequest 中
```

上述设计看上去不错，但并非优秀的设计，它泄漏了服务端实现的细节（采用了缓存）。随着业务的发展，如果后续采用一个新的不带缓存的服务端存储实现，再要支持这个 useCache 的字段就很不合适了。当然，在实践中这一问题可以用不同的服务实例来解决（如抽象处理器的多个实现），通过不同访问的 EndPoint 配置来区分。

### 3. API 设计实践举例

#### **3.1 经典范例**

谈及 API 设计，有一个经典的范例总是被拿出来“瞻仰”，那就是 File API。在此列举 File API 的部分接口，如下所示：

```C
int open(const char *path, int oflag, .../*,mode_t mode */);
int close (int filedes);
int remove( const char *fname );
ssize_t write(int fildes, const void *buf, size_t nbyte);
ssize_t read(int fildes, void *buf, size_t nbyte);
```

**File API 为什么被公认为经典的 API 设计？**

- File API 历经三十余年风雨，在此期间，硬/软件系统经历数代更迭，但 File API 核心却立于不败之地。
- File API 提供了非常清晰的概念模型，工程师很容易理解 API 背后的基础概念：什么是文件，以及相关联的操作（open、close、read、write），清晰明了；
- File API 支持多种不同文件系统实现，如磁盘、块设备、管道（pipe）、共享内存、网络、终端等。这些设备类型差异显著：有的是随机访问，有的仅支持顺序访问，有的是持久化，有的是非持久化，但是这些设备构建的文件系统都都可以采用 File API，上层系统不必关注底层实现。

#### **3.2 选择合适的抽象层**

与前面的一个问题密切相关的，是在定义对象时需要选择合适的抽象的层级。不同概念之间往往相互关联，以 File API 为例，在设计这样的 API 时，选择抽象的层级的可能的选项有多个，例如：

- 文本、图像混合对象
- 数据块抽象
- 文件抽象

这些不同的层级的抽象方式，可能描述的是同一个东西，但是在概念上是不同层面的选择。当设计一个 API 用于与数据访问的客户端交互时，**文件**是更合适的抽象，而设计一个 API 用于文件系统内部或者设备驱动时，**数据块**应是合适的抽象，当设计一个文档编辑工具时，可能会用到**文本图像混合对象**这样的文件抽象层级。

以数据库相关的 API 为例，底层的抽象可能针对的是数据的存储结构，中间层是数据库逻辑层需要定义数据交互的各种对象和协议，而在展示层需要的抽象又有不同。

#### **3.3 为对象/资源设计合适的操作**

对于确定的对象（或者称资源），我们通常需要设计对应的操作，如 CRUD（create、read、update、delete）。在设计操作时，“**概念上合理**”是需要重点考虑的原则，换句话说，Operation + Resource 连起来应具备客观上的合理性。

举个例子：

> 一个 API 的操作对象是商品库存（Stock），那么如下操作是比较自然的：
>
> 1. Update Stock（更新库存）
> 2. Create Stock (创建库存）
>
> 但是，Transfer Stock（转移库存）就不太自然，从概念上理解，转移操作有点赘余，它完全可以由更新操作实现。

#### **3.4 更新操作尽量保持幂等性**

幂等性，指的是一种操作具备的性质，具有这种性质的操作可以被多次实施并且不会影响到初次实施的结果。幂等性在系统设计中会带来很多便利性，例如客户端可以更安全地重试，从而让复杂的流程实现更为简单。在实践中，幂等性实现有以下几种常见类型。

**Create 类型的幂等**

创建的幂等，多次调用容易出现重复创建，为实现幂等性，常见的做法是使用客户端生成的唯一 ID，在反复重试时使用同一个 ID，便于服务端识别重复。

**Update 类型的幂等**

更新的幂等，对于更新类的操作，通常有两类实现方式：

- Incremental（数量增减），如 IncrementBy(3) 这样的语义
- SetNewTotal（设置新的总量），如 SetNewTotal(3) 这样的语义

IncrementBy 这样的语义重试的时候难以避免出错，而 SetNewTotal 语义则比较容易具备幂等性。IncrementBy 也有优点，即多个客户请求同时增加的时候，比较容易并行处理，而 SetTotal 可能导致并行的更新相互覆盖或相互阻塞。更新增量和设置新的总量这两种语义各具特点，需要根据场景来决策，如果必须优先考虑并发更新的情景，可以使用更新增量的语义。

**Delete 类型幂等**

Delete 的幂等，往往在于一个对象被删除后，再次试图删除可能会由于数据无法被发现导致出错。这个行为虽然严格意义上不幂等，但是通常也无副作用。

#### **3.5 变更应向下兼容**

API 的变更需要向下兼容，具体而言，即不影响**老的客户端正常访问服务端的新版本**（同一个大版本下）。这一点对于远程的 API（HTTP/RPC）尤其重要。关于兼容性，已经有很好的总结，常见的不兼容变化包括但不限于：

- 删除一个方法、字段或者 Enum 的数值；
- 方法、字段改名；
- 方法名称字段不改，但是语义和行为变化。

不兼容 API 的废弃是一个过程，具体而言，对于一个不兼容的 API 变更，需要通过一个过程来实现。一般来说，需要在保持对老版本的兼容性的前提下，支持新老字段/方法/语义，以给客户端足够的升级时间，这样的过程比较耗时，但十分必要。从另一个角度看，注重 API 的设计可以最大限度地避免升级时的不兼容。

不靠谱的“同步发布”，对于内部的 API 升级，有些工程师会采用一种叫“同步发布”的模式来做不兼容变更，即通知所有的客户端，服务 API 要做一个不兼容变更，所有关联方一起发布，同时更新，切换到新的接口。这样的方法是不可取的，多个系统之间的“同步更新”是无法实现的，一旦出现问题更难以回滚。

#### **3.6 批量更新应尽量由客户端实现**

批量更新如何设计是另一个常见的 API 设计决策。这里我们常见有两种模式，即客户端批量更新或者服务端实现批量更新，如下图所示：

![在这里插入图片描述](https://images.gitbook.cn/300d8600-8179-11ea-b37d-17b17aab2bc1)

API 的设计者可能会希望实现一个服务端的批量更新能力，但是除非对于客户端来说提供原子化+事务性的批量很有意义，否则建议要尽量避免这样做。实现服务端的批量更新有诸多的弊端，而客户端批量更新则有优势：

- 服务端批量更新带来了 API 语义和实现上的复杂度，例如当部分更新成功时的语义、状态表达等；
- 即使我们希望支持批量事务，也要考虑到是否不同的服务端实现都能支持事务性；
- 批量更新往往给服务端性能带来很大挑战，也容易被客户端滥用；
- 客户端实现批量更新，可以更好地将负载由不同的服务端来承担；
- 客户端批量更新可以更灵活地由客户端决定失败重试策略。

#### **3.7 警惕对象/资源更新的风险**

由于 API 设计存在缺陷或系统迭代需要，在实践中，有时需要对 API 的参数（Object/Resource）进行更新（通常是增加），举例如下：

```Java
QueryOrderResponse queryOrder(QueryOrderRequest request)
```

Before：

```Java
QueryOrderRequest{
private int pageSize;
private int pageNum;
}
```

After：

```Java
QueryOrderRequest{
private int pageSize;
private int pageNum;
private boolean firstPage；
}
```

这类更新有一些潜在的风险作为 API 设计者必须了解。API 更新的时候，更新对象 QueryOrderRequest 在服务端可能已经有了新的成员（属性-attribute），而客户端尚未更新并不知道该新成员。服务端增加一个新的成员一般来说是兼容的变更，但是，有两种情况需要注意：

1. 参数校验问题，服务端对于新增的成员不能做强参数校验。因为，对于那些尚未更新的客户端并不知道新增成员，服务端反序列化后，新增成员会填充默认值，而这些默认值往往无法通过强校验；
2. 如果新成员关联的服务端资源之前被一个知道这个新成员的客户端设置了值，而这时一个不知道这个新成员的客户端来操作，关联的服务端资源可能会被默认值覆盖。

#### **3.8 统一错误码**

API 的设计者有时很想创建自己的 Error Code，或者是表达返回错误的不同机制，因为每个 API 都有很多的细节的信息，设计者想表达出来并返回给用户，以便为用户提供更多的决策信息，但事实上，泛化的 Error Code 会使 API 变得复杂难用。

Error-handling 是用户使用 API 非常重要的部分。为了让用户更容易地使用 API，**最佳的实践应该是用标准、统一的 Error Code，而不是每个 API 自己去创立一套**。例如 HTTP 有规范的 error code，Google Could API 设计时都采用统一的 Error code。为什么不建议自己创建 Error code 机制？

- Error-handling 是客户端的事，而对于客户端来说，是很难关注到那么多错误的细节的，一般来说最多分两三种情况处理。客户端最关心的通常是：这个 Error 是应该重试还是应该继续向上层返回错误？而不是区分不同的 Error 细节。
- 有人觉得提供更多的自定义的 Error Code 有助于传递信息，但是这些信息除非有系统分别处理才有意义。如果只是传递信息的话，Error Message 里面的字段可以达到同样的效果。

### 4. 总结

本文作为《主题 1：如何设计一个好的 API》的延续，介绍了 API 设计的一些实践经验，当然，正如笔者一直强调的观点——没有一种普适性的方法或设计可以适用于所有场景，因此读者在实践中应根据具体的场景具体分析。