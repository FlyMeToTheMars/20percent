## 主题 07：如何进行 Java 系统性能优化（上）

### 1. 引言

系统性能优化涉及面非常广，涵盖方案优化、编码优化、并发优化、JVM 调优等诸多方面的知识。

虽然不同系统的优化策略存在差异，但从全局来看，它们的共性仍是主要的。首先，我们可以从方案设计、编码、并发设计、JVM 等方面去优化我们的系统；然后，可以通过一些 Linux 系统命令和工具去发现系统的性能瓶颈；最后，结合业务特点采用缓存、异步化、并发等方式对系统进行“定制”优化。

**本文为 “Java 系统性能优化系列”的上篇，主要内容如下：**

1. 评估系统性能的指标、Amdahl 定理、系统优化路线
2. 识别 Java 应用性能瓶颈的方法与工具
3. 系统优化之方案设计优化、编码优化

### 2. 预备知识

关于系统性能，经过多年的发展已经形成了一个包含系列指标的评价体系，本节将对其进行简要介绍。此外，本节还将简述系统优化的步骤和测试验证方法。

#### **2.1 评估系统性能的参考指标**

**资源指标**

- **CPU 使用率**：指用户进程与系统进程消耗的 CPU 时间百分比，长时间持续运行的情况下，一般可接受上限不超过 85%。
- **内存利用率**：用于评估程序在运行时占用的内存空间，计算公式为：内存利用率 = ( 1 - 空闲内存/总内存大小 ) * 100%，一般内存使用率可接受上限为 85%。
- **磁盘 I/O**：磁盘主要用于存取数据，因此 IO 操作也有读、写之分，存数据的时候对应的是写 IO 操作，取数据的时候对应的是读 IO 操作，一般使用“%Disk-Time”（磁盘用于读写操作所占用的时间百分比）度量磁盘读写性能。
- **网络带宽**：一般使用计数器“Bytes-Total/sec”来度量，“Bytes-Total/sec”表示为发送和接收字节的速率，包括帧字符在内。判断网络连接速度是否是瓶颈，可以用该计数器的值和目前网络的带宽比较。

**系统指标**

- **执行时间**：一段代码从开始执行到运行结束所需要的时间。
- **响应时间**：对请求作出响应所需要的时间，一般包括网络传输时间、应用服务器处理时间、数据库服务器处理时间。
- **吞吐量**：指单位时间内系统处理用户的请求数。从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量；从网络角度看，吞吐量可以用：字节/秒来衡量。
- **并发用户数**：并发数用于衡量软件系统的并发处理能力，和吞吐量不同，它大多是占用套接字、句柄等操作系统资源。

#### **2.2 原理定律了解**

**木桶原理**

大意：一只木桶盛水的多少，并不取决于桶壁上最高的那块木块，而是取决于桶壁上最短的那块。 木桶原理应用到软件系统中可以这样理解：对于一个软件系统，影响其性能的因素并不唯一，常见因素有内存资源、CPU 资源、磁盘 I/O 等，即使系统拥有充足的内存和CPU 资源，但如果磁盘 IO 性能低下，那么系统性能总体上还是不高。

**阿姆达尔（Amdahl）定律**

阿姆达尔定律是计算机系统设计的重要定量原理之一，于 1967 年由 IBM 360 系列机的主要设计者 Amdahl 首先提出。该定律是指：系统中对某一部件采用更快执行方式所能获得的系统性能改进程度，取决于这种执行方式被使用的频率，或所占总执行时间的比例。阿姆达尔定律实际上定义了采取增强（加速）某部分功能处理的措施后可获得的性能改进或执行时间的加速比。

> 加速比 = 优化前系统耗时/优化后系统耗时

加速比越大，表明系统优化效果越明显。关于加速比的计算，在计算机领域还有另外一个公式，如下：

![enter image description here](https://images.gitbook.cn/11e62630-05c6-11e9-b37a-bbc022d7aefd)

参数 F（系统内必须串行化的比重）相对而言比较难理解，在此，我举一个例子加以说明。如下所示，一个程序（计算机应用）包含 5 个步骤，每个步骤需耗时 100ms，其中步骤 2、步骤 4 可以并行，其它步骤只能串行。

![enter image description here](https://images.gitbook.cn/39637c10-05c8-11e9-a836-fd812b4d8008)

根据阿姆达尔定律，该系统的串行化的比重：

> F=3/5=0.6

由于该系统中，步骤 2、步骤 4 可以并行执行，因此，如果增加 CPU 的数量，以并行替代串行，便可以减少耗时，如下所示：

![在这里插入图片描述](https://images.gitbook.cn/6acbd8e0-52f9-11ea-b2e1-7d26d62747f1)

经过并行优化后，

> 加速比 = 500ms/400ms = 1.25

不难想见，如果 CPU 的数量无限多，那么步骤 2、步骤 4 的处理耗时将逼近 0，加速比的极限为：

> 500ms/300ms = 1.67

当然，加速比也可以通过上面的公式计算得出，如下所示：

![enter image description here](https://images.gitbook.cn/f6183280-05f8-11e9-a836-fd812b4d8008)

#### **2.3 优化步骤**

在实际应用中，系统的优化大致可以分为以下几个步骤：

1. 确定优化目标；
2. 测试系统是否满足目标；
3. 如果不满足，则排查系统瓶颈所在；
4. 对系统瓶颈进行优化，继续 2、3 步骤，直到达到目标；

![enter image description here](https://images.gitbook.cn/3fab13d0-05fa-11e9-a836-fd812b4d8008)

需要强调的是，优化不能盲目进行，一定要在代码可读性、可扩展性和系统性能之间做出权衡。同时，坊间有言——“过早的优化是另一种罪恶的来源”，优化应该由真实业务场景来驱动，而不是无病呻吟，为优化而优化。

#### **2.4 测试验证**

在系统优化过程中，为了判定系统是否已经达到目标要求，需要对系统进行压力测试。 当前很多工具可以帮助我们进行系统压测，比如 Loadrunner、JMeter 等优秀的测试工具。

**压测指标**

CPU 使用率、JVM 堆栈使用情况、GC/FGC 次数、Load 指标、网络延时等，重点关注以下指标：

- CPU 和 Load 值
- 要求满足 CPU <= 85%
- Load < CPU 数 *1.2 的情况下系统的 TPS 和 QPS 满足业务要求

### 3. 识别系统性能瓶颈

性能瓶颈实际上就是一个软件系统的性能缺陷，也是我们要优化的点，那么，如何识别一个系统的性能瓶颈呢？本节将介绍几种常见的方法。

#### **3.1 通过命令识别性能瓶颈**

**1. Linux 系统命令**

- **top**

top 命令是 Linux 下常用的性能分析工具，能够实时显示系统 CPU、内存、Load、进程等信息，类似于 Windows 的任务管理器。

- **sar**

sar（system activity reporter）是目前 Linux 上最为全面的系统性能分析工具之一，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的情况、磁盘 I/O、CPU 效率、内存使用状况、进程活动及 IPC 有关的活动等。

例子：每秒采集一次 CPU 信息，共采集 10 次。

```Bash
sar -u 1 10 
```

- **vmstat**

vmstat（virtual meomory statistics）命令可对操作系统的虚拟内存、进程、CPU 活动进行监控。它是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。vmstat 工具提供了一种低开销的系统性能观察方式，即便在高负荷的服务器上也能轻松使用。

例子：每秒采集信息，共采集 10 次。

```Bash
vmstat 1 10 
```

- **iostat**

iostat 命令用于报告 CPU 统计信息和整个系统、磁盘和 CD-ROM 的输入/输出统计信息。根据 iostat 命令产生的报告，用户可确定一个系统配置是否平衡，并据此在物理磁盘与适配器之间更好地平衡输入/输出负载。iostat 工具的主要目的是通过监控磁盘的利用率，而探测到系统中的 I/O 瓶颈。

例子：每秒采集信息，共采集 10 次。

```Bash
iostat 1 10 
```

- **pidstat**

pidstat 是 sysstat 工具的一个命令，主要用于监控全部或指定进程占用系统资源的情况，如 CPU、内存、设备 IO、任务切换、线程等。

例子：采集指定进程的 CPU 信息。

```Bash
pidstat -p 1187 1 3 -u -t 
```

- **dstat**

dstat 命令是一个用来替换 vmstat、iostat、netstat、nfsstat 和 ifstat 这些命令的工具，是一个全能系统信息统计工具，可以实时的监控 CPU、磁盘、网络、IO、内存等使用情况。

例子：

```
dstat -clm
```

实时监控系统 CPU、Load、内存信息。压测过程中经常使用该命令进行系统监控。

**2. JDK 命令**

JDK 提供了很多内置的小工具，这里介绍几种使用频率最高的工具。

- **jps**

jps（Java Virtual Machine Process Status Tool）是从 JDK 1.5 开始提供的一个显示当前所有 Java 进程 pid 的命令，简单实用，非常适合在 Linux/Unix 平台上简单察看当前 Java 进程的一些简单情况。

例子：用于输出 Java 进程的 pid、进程参数、函数完整路径、虚拟机配置参数。

```Bash
jps -m -l -v 
```

- **jstat**

jstat（Java Virtual Machine Statistics Minitoring Tool）用于观察 Java 应用程序运行时的信息工具。该命令有众多选项，可以用来统计加载的类信息、GC 信息、堆内存分配信息等。

例子：

```Bash
jstat -gcutil 2972
```

- **jmap**

jmap（Java Memory Map）主要用于打印指定 Java 进程（应用程序）的堆快照和对象的统计信息。

例子：统计 PID 为 2927 的 Java 程序的对象统计信息。

```Bash
jmap -histo 2927 > a.txt 
```

例子：统计 PID 为 2927 的 Java 程序的当前堆快照信息。

```Bash
jmap -dump:format=b,file=a.txt 
```

- **jhat**

jhat（Java Head Analyse Tool）主要是用来分析 Java 堆的命令，可以将堆中的对象以 HTML 的形式显示出来，包括对象的数量、大小等等，并支持对象查询语言。

例子：

```Bash
jhat heap.hprof
```

- **jstack**

jstack 工具可以用来查看 Java 进程里的线程信息，根据这些线程堆栈信息，可以去检查 Java 程序出现的问题，如：检测死锁并输出死锁的信息。

例子：

```Bash
jstack -l 2348 > a.txt
```

#### **3.2 通过可视化工具识别性能瓶颈**

**JConsole**

从 Java 5 开始引入了 JConsole。JConsole 是一个内置 Java 性能分析器，可以从命令行或在 GUI shell 中运行。可以轻松地使用 JConsole 来监控 Java 应用程序性能（内存、CPU、线程的使用情况等）和跟踪 Java 中的代码。作为 JDK 自带的监控工具，操作简便，比较容易上手。

**Virtual-VM**

VisualVM 是一款免费的，集成了多个 JDK 命令行工具（包括 jstat、jamp、jhat、jstack 等）的可视化工具，它能提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作。

### 4. 系统优化—方案设计优化

在设计方案时，合理的采用 Java 设计模式和常用的优化思想（如池化对象、并行代替串行等）常常能起到事半功倍的效果。

#### **4.1 善用设计模式**

设计模式（Design pattern）代表了最佳的实践，它是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

目前，公认的 Java 设计模式有 23 种，其中常用的有：单例模式、工厂模式、适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式、策略模式、模板方法模式、观察者模式。设计模式涉及的内容非常多，网上有大量的资料，本文不展开。

#### **4.2 善用优化组件和策略**

**缓冲**

缓冲区是一块特定的内存区域。开辟缓冲区的目的是通过缓解应用程序上下层之间的性能差异，提高系统的性能。缓冲可以协调上层组件和下层组件的性能差。当上层组件性能优于下层组件时，可以有效减少上层组件对下层组件的等待时间。基于这样的结构，上层应用组件不需要等待下层组件真实地接受全部数据，即可返回操作，加快了上层组件的处理速度，从而提升系统整体性能。缓冲最常用的场景就是提高 I/O 速度，为此，JDK 中有不少 I/O 组件都提供了缓冲功能，例如：BufferedWriter、BufferedOutputStream。

**缓存**

缓存也是一块为了提升系统性能而开辟的内存空间。缓存的主要作用是暂存数据处理结果，以供下次访问使用。在很多场景中，数据的处理、获取可能会非常费时，当对这类数据的请求量很大时，频繁的 I/O 和数据处理会极大的降低性能，缓存的作用就是将这类数据暂存起来，当有其它线程、客户端需要查询相同的数据资源时直接使用，这样就可以省略对这些数据的处理流程，而直接从缓存中获取处理结果。

**对象池**

对象池化，是目前常用的一种系统优化技术。它的核心思想是：缓存和共享，即对于那些被频繁使用的对象，在使用完后不立即将它们释放，而是将它们缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的次数，进而改善应用程序的性能。缓存对象如同将对象放入一个池中，因此，这种策略被形象的称为“对象池化”。在实现细节上，对象池可能是一个数组，一个链表或者任何集合类。比较常用的比如线程池，数据库连接池。在程序中使用数据库连接池和线程池，可以有效地改善系统在高并发下的性能。这是两个非常重要的性能组件。任何对性能敏感的系统，都需要考虑合理配置这两个组件。此外，由于对象池技术将对象限制在一定的数量，也有效地减少了应用程序内存上的开销。

**并行替代串行**

随着多核时代的到来，CPU 的并行能力有了很大的提升。在这种背景下，传统的串行程序已经无法发挥 CPU 的最大潜能，造成系统资源的浪费。鉴于此，根据应用场景，应考虑并行替代串行的可行性，以便充分利用 CPU 资源。

**负载均衡**

对于一个应用，如果并发数非常多，单台服务器无法承受时，为保证应用程序的服务质量，就需要使用多台服务器协同工作，将系统负载尽可能均匀地分配到各个服务器节点上，使得各个服务器都能高效的工作，防止“空转”或“过载”。

**时间换空间**

时间换空间通常用于嵌入式设备或者内存、硬盘空间不足的场景。通过牺牲时间（CPU 资源或者网络资源等）的策略，实现原本需要更多内存或者硬盘空间才能完成的工作。

例如，实现 a、b 两个变量的互换，

```
a = a + b; b = a - b; a = a - b
```

以增加 CPU 运算的代价减少了内存空间的使用。

**空间换时间**

与时间换空间的方法相反，空间换时间则是尝试使用更多的内存或者磁盘空间换取时间（CPU 资源或者网络资源等），通过增加系统的内存消耗，来加快程序的运行速度。典型的应用实例就是缓存。

### 5. 系统优化—编码优化

关于 Java 编码优化，涉及的点非常多，为指导编码，互联网公司通常都有各自的“编码规约”（如阿里的《Java 编码规约》），规约本质上就是 Java 编码优化点的集合。编码优化是一个相对庞大的体系，不便展开，本节仅介绍部分内容供读者参考。

#### **5.1 合理指定类、方法的 final 修饰符**

带有 final 修饰符的类是不可派生的。在 Java 核心 API 中，有许多应用 final 的例子，例如 java.lang.String，整个类都是 final 的。为类指定 final 修饰符可以让类不可以被继承，为方法指定 final 修饰符可以让方法不可以被重写。如果指定了一个类为 final，则该类所有的方法都是 final 的。Java 编译器会寻找机会内联所有的 final 方法，内联对于提升 Java 运行效率作用重大。

#### **5.2 及时关闭流**

Java 编程过程中，进行数据库连接、I/O 流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。

#### **5.3 尽量减少对变量的重复计算**

需要注意，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。示例如下：

```Java
// list.size() 会重复计算
for (int i = 0; i < list.size(); i++)
{...}
```

修改后：

```Java
for (int i = 0, size = list.size(); i < size; i++)
{...}
```

#### **5.4 谨慎用异常**

异常对性能不利。抛出异常首先要创建一个新的对象，Throwable 接口的构造函数调用名为 fillInStackTrace() 的本地同步方法，fillInStackTrace() 方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java 虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。

#### **5.5 慎用锁**

并发场景下，同步调用应该去考量锁的性能损耗：

- 能用无锁数据结构，就不要用锁；
- 能锁区块，就不要锁整个方法体；
- 能用对象锁，就不要用类锁。

#### **5.6 避免用 Apache Beanutils 进行属性的 copy**

Apache BeanUtils 性能较差，可以使用其他方案，比如 Spring BeanUtils、Cglib BeanCopier，注意均是浅拷贝。详情[参考文章](https://www.jianshu.com/p/bcbacab3b89e)。

#### **5.7 核心数据结构**

尽量使用 HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、ConcurrentHashMap、Vector、StringBuffer，后三者由于使用同步机制而增加了性能开销。

**List**

理解 LinkedList 和 ArrayList 的区别，根据场景选用。

- **LinkedList：**使用链表实现，随机插入删除数据相对高效，随机的定位查询相对低效，不会出现扩容问题。
- **ArrayList：**使用数组实现，随机的定位查询相对高效，随机插入删除数据行相对低效，会有扩容问题。

**Map**

理解 HasMap，LinkedHasMap，TreeMap 的区别，根据场景选用。

- **HasMap：**分桶 hash，直接对 Key 做 hash 分桶存储，最好的情况下可以做到 O(1) 的访问，需要关注扩容以及冲突处理问题。
- **LinkedHasMap：**通过维护一个运行于所有条目的双向链表，保证了元素迭代的顺序，相较于 HasMap 性能降低，但是有序的。
- **TreeMap：**采用红黑树，对 Key 进行排序存储数据，由于红黑树是自平衡的，理论上可以做到 O(log(n)) 的访问。

**Set**

理解 HashSet、LinkedHashSet、TreeSet 的区别，根据场景选用。本质上 Set 都是对 Map 的封装，可以理解 Map 的 Key 就是 Set。

#### **5.8 其它**

- 循环内不要不断创建对象引用；
- 乘法和除法尽量使用移位操作；
- 程序运行过程中避免使用反射；
- 使用最有效率的方式去遍历 Map，推荐采用迭代器。

### 6. 总结

本文为“**Java 系统性能优化系列**”的上篇，首先介绍了评估系统性能的指标、Amdahl 定理及系统优化路线。然后，针对 Java 系统，介绍性能瓶颈的识别方法和工具。最后，介绍了两种系统优化方案，即设计优化、编码优化。

限于篇幅，关于 Java 系统性能优化的方案，本文只介绍了两个点，更多内容将在下一篇文章——《如何进行 Java 系统性能优化（下）》进一步介绍。