# 如何彻头彻尾了解 MySQL 的索引

如果正确合理设计并且使用索引的 MySQL 是一辆兰博基尼的话，那么没有设计和使用索引的 MySQL 就是一个人力三轮车。

没有索引的表，单表查询可能几十万数据就是瓶颈，那到底该如何应对互联网企业的上亿的数据？

MySQL 中的 InnoDB 存储引擎的核心在于索引，索引的核心在于 B + tree，所以说要想了解 MySQL 中索引，我们必须要先了解 B + tree ，而 B + tree 的说白了就是一颗平衡多叉树。

索引是存储引擎用于快速找到记录的一种数据结构，可以让服务器快速定位到表的指定位置。在查找数据时，存储引擎先在索引中找到对应的值，然后根据所匹配的索引记录找到对应的数据行。索引列的顺序非常重要，MySQL 只能高效的使用索引的最左前缀列。

### 索引的优点

1、减少服务器需要扫描的数据量；

2、帮服务器避免排序和临时表；

3、将随机 IO 变为顺序 IO。

### 索引的缺点：

1、需要额外的维护成本，降低数据更新的速度；

2、占用内存和磁盘的空间。

说到索引是一种数据结构，那么都知道索引是一种 B + Tree 的结构，如下图所示，

![enter image description here](https://images.gitbook.cn/3229f960-995d-11e8-aa96-7f69295f1853)

最外层浅蓝色磁盘块 1 里有数据 17、35（深蓝色）和指针 P1、P2、P3（黄色）。

P1 指针表示小于 17 的磁盘块，P2 是在 17 - 35 之间，P3 指向大于 35 的磁盘块。真实数据存在于子叶节点也就是最底下的一层 3、5、9、10、13 ...... 非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如 17、35。

查找过程：例如搜索 28 数据项，首先加载磁盘块 1 到内存中，发生一次 I/O，用二分查找确定在 P2 指针。接着发现 28 在 26 和 30 之间，通过 P2 指针的地址加载磁盘块 3 到内存，发生第二次 I/O。

用同样的方式找到磁盘块 8，发生第三次 I/O。

真实的情况是，上面 3 层的 B + Tree 可以表示上百万的数据，上百万的数据只发生了三次 I/O 而不是上百万次 I/O，时间提升是巨大的。

上文提到的磁盘块，那么一个磁盘块可以存储多少数据呢，每个磁盘块根据系统的不同，文件系统的不同可能会不一样大。

可能是有的是 512 byte，或者 2 k。那么如果知道一个索引字段的大小是多少，就可以知道一个磁盘块上可以有多少个索引了。

### 二叉树

说到底 B + Tree 就是一棵多查平衡树，那就我们拿二叉平衡树，来看看树的创建过程，转置过程。

AVL 树的旋转一共有四种情形，注意所有旋转情况都是围绕着使得二叉树不平衡的第一个节点展开的。

1.LL型

平衡二叉树某一节点的左孩子的左子树上插入一个新的节点，使得该节点不再平衡。

这时只需要把树向右旋转一次即可，如图所示，原 A 的左孩子 B 变为父结点，A 变为其右孩子，而原B的右子树变为 A 的左子树，注意旋转之后 Brh 是 A 的左子树（图上忘在 A 于 Brh 之间标实线）

![enter image description here](https://images.gitbook.cn/39fe5e60-995d-11e8-aa96-7f69295f1853)

2.RR 型

平衡二叉树某一节点的右孩子的右子树上插入一个新的节点，使得该节点不再平衡。

这时只需要把树向左旋转一次即可，如图所示，原 A 右孩子 B 变为父结点，A 变为其左孩子，而原 B 的左子树 Blh 将变为A的右子树。

![enter image description here](https://images.gitbook.cn/3e9dfe30-995d-11e8-aa96-7f69295f1853)

3.LR 型

平衡二叉树某一节点的左孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时需要旋转两次，仅一次的旋转是不能够使二叉树再次平衡。

如图所示，在 B 节点按照 RR 型向左旋转一次之后，二叉树在 A 节点仍然不能保持平衡，这时还需要再向右旋转一次。

![enter image description here](https://images.gitbook.cn/43efaff0-995d-11e8-aa96-7f69295f1853)

4.RL 型

平衡二叉树某一节点的右孩子的左子树上插入一个新的节点，使得该节点不再平衡。

同样，这时需要旋转两次，旋转方向刚好同 LR 型相反。

![enter image description here](https://images.gitbook.cn/493839f0-995d-11e8-aa96-7f69295f1853)

看完二叉树的转置后，我们可以将此过程映射到 B + Tree 的转置上。

### 聚簇索引和非聚簇索引

#### 聚簇索引

看完索引，以及了解了二叉树的转置，接下来我们看一下索引的分类， 索引大面上分为聚簇索引 和 非聚簇索引。

B + Tree 所有索引数据都在叶子结点上，并且增加了顺序访问指针,每个叶子节点都有指向相邻叶子节点的指针。

先来说一下聚簇索引，聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。

InnoDB 的聚簇索引实际上在同一个结构中保存了 B + Tree 索引和数据行。

叶子节点包含行的所有数据，节点页只包含了索引列。

如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替；如果没有这样的索引 InnoDB 会隐式定义一个主键来作为聚簇索引当然聚簇索引的存储方式也是 B + Tree。

#### 非聚簇索引

非聚簇索引，和聚簇索引最大的区别就是数据的存储上， 聚簇索引不仅存储了索引的数据，还在叶子节点中存储了对应的 table 中的数据，记录的索引顺序与物理顺序相同。而非聚簇索引则存储的是索引数据并且在叶子上存储了聚簇索引的值。

所以说通过聚簇索引查找数据， 只需要一次便可以拿到自己想要的记录， 而非聚簇索引聚簇索引需要两次。

### 索引优化

#### 索引的创建原则

1．选择唯一性索引，这样会使得索引的效率是最高的。

2．为经常需要排序、分组和联合操作的字段建立索引，提高索引的使用率，就能提高查询的 sql 的效率。联合字段建立索引是非常必要的，所以我们大部分的表连接都是主键+外键的形式。

3．为常作为查询条件的字段建立索引。

4．限制索引的数目。如果把每一个字段都建立上索引，那么数据的更新就会非常慢，并且索引过多会占用大量的磁盘空间。

5．尽量使用字段短的索引，这样提高索引的检索效率。

6．尽量使用前缀来索引。这个是针对字段长度比较长的字段建立索引的原则，这样能使的索引的查询效率比较高。

7．删除不再使用或者很少使用的索引。没有用的索引，不仅会占用空间，而且还会影响更新的速度。

### 索引优化

#### 多列索引

正确的索引顺序依赖于使用该索引的查询，同时需要考虑如何更好的满足排序和分组的需求。

在一个 Btree 索引中，索引的顺序意味着索引首先按照最左列进行排序，其次是第二列，因此索引可以按照升序或是降序进行扫描，以满足精确符合列顺序的 Order By、Group By 和 Distinct 等查询语句，因此多列索引的列顺序至关重要。

当不需要考虑排序和分组时，将选择性最高的列放在前面通常是好的，这时候索引的作用只是用于优化 Where 条件查询。

#### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 “ 覆盖索引 ”。

MySQL 可以使用索引来直接获取列的数据，这样就不在需要读取数据行了。

覆盖索引必须要存储索引列的值，哈希索引、空间索引和全文索引都不存储列值，MySQL 只能使用 Btree 索引作为覆盖索引。

排序 MySQL 支持两种方式生成排序结果：通过排序操作；通过索引顺序扫描，MySQL 可以使用同一个索引既满足查找又满足排序，只有当索引的列顺序和 Order By 子句的顺序完全一致，并且所有列的排序方向也一样时，才能使用索引进行排序，其中 Order By 子句和查询限制一样，需要满足索引的最左前缀匹配，当前导列为常量时，可以不满足最左前缀的要求。

#### 冗余和重复索引

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，一旦发现重复索引，应该立即移除。

冗余索引与重复索引有些不同，如果创建了索引（A, B），再创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引；索引（A, ID）对于 InnodDB 来说主键列已经包含在二级索引中，所以也是冗余。

应尽量扩展已有索引而不是创建新的索引，但也有时候出于性能考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询性能，特别是 count，group by 等统计查询。

未使用的索引，就是永远都用不到的索引，这种索引就是累赘，直接删除。

#### 前缀索引和索引选择性

MySQL 无法使用前缀索引做 Group By 和 Order By，也无法使用前缀索引做覆盖扫描。

MySQL 本身不支持反向索引，但可以将字符串反转后存储，并基于此建立前缀索引。

### 索引失效

1、没有遵守最左前缀原则。

2、使用了范围查询（>,<,<>，!=,between and ,like)，该条件查询右边的列都会失效。

3、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。

4、表中数据量比较小的时候，MySQL 优化引擎，会决定不实用索引。

5、使用 or 进行查询，联合索引会失效。

6、不在索引列上做任何操作（计算，函数，（自动或者手动）类型装换），会导致索引失效而导致全表扫描。

### 索引与锁

1、索引可以让查询锁定更少的行，InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。

2、如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器层以后，MySQL 服务器才能应用 Where 子句，InnoDB 已经锁定这些行，到适当的时候才能释放。

3、如果不能使用索引查找和锁定行的话问题会更糟糕，MySQL 会做全表扫描并锁定所有行。

4、InnoDB 在二级索引上使用共享锁，在主键索引使用排它锁。

### 其他索引

#### hash 索引

1、hash 索引基于哈希表实现，只有精确匹配索引的所有列的查询才会生效。

2、Hash 索引将所有哈希值存储在索引中，同时保持指向每个数据行的指针。

3、Hash 索引结构非常紧凑，查找速度非常快。

4、Memory 引擎支持非唯一的哈希索引。

5、InnoDB 有一个功能叫 “ 自适应哈希索引 ”，当它注意到某些列索引值被使用的非常频繁时，会在内存中基于 Btree 索引之上再建一个 hash 索引，以提高访问速度

### 空间数据索引

MyISAM 表支持空间索引，可以作为地理数据存储。但 MySQL 对 GIS 支持不够全面。

### 全文索引

1、全文索引是一种特殊类型的索引，他查找的是文中的关键词，而不是直接比较索引中的值。

2、全文索引有很多的细节需要调整，比如分词、停用词、词干、复数、布尔查询等。

3、MySQL 对空间数据索引和全文索引支持都不是很好，如果有此功能需求，建议使用其他存储引擎，如 monogDB 或基于 lucene 的solr、es。

### 总结

这次 MySQL 的内容就讲这么多，下次给大家分享 MVCC 的机制！