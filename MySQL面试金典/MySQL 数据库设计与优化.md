# MySQL 数据库设计与优化

### 一、开篇说明

本文主要主要从六个方面：数据库设计原则、业务逻辑场景分析、数据库对象结构优化、SQL 执行效率查看及优化、业务应用优化、MySQL Server 数据库服务端优化，来告诉后端开发人员及数据库设计人员如何提高数据库的执行效率，从而对整个业务系统有良好的性能提升。

我们在做业务系统的过程中数据库设计是基础，所以在一个系统进行开发之前我们必须尽可能多地考虑到目前的业务需求，以及以后系统扩展过程中可能会遇到的问题。

### 二、熟悉理解 MySQL 的数据库设计原则

学习内容和目的：

本节内容主要是为了让大家掌握和理解 MySQL 数据库设计的规范和原则，在数据库设计之前先了解其规范和原则。需要理解为什么它会给这样的原则，这样的原则好处是什么，能给数据库的性能带来怎样的效果。

#### MySQL 数据库设计规范

**数据库命名**

数据库的命名包括英文字母（区分大小写）、阿拉伯数字、下划线，命名必须遵循简洁、明确的设计规则，切记数据库命名不能是纯数字的形式。通常我们的数据库命名是这样的，例如，简洁一些，user；当然一般情况下，我们可以给数据库加一个前缀，school_user；当我们需要使用备份数据库的时候，可以加入数字，比如 school_user_20190210（后面的数字一般代表时间，2019 年 2 月 10 日）。

**数据库表命名**

通常数据库表的命名和数据库名的命名规范是一致的，这里我们参考数据库的命名规范即可。

**字段命名规范**

字段命名一般使用多个单词之间使用下划线的规则，比如：user_id（用户 ID）、add_time（添加时间）。每个表中必须设置主键的字段，使用主键使每条数据具有不可重复性，一般有两种：一种是利用自增主键，一种使用自定义的主键。至于具体使用哪种方式要从业务角度出发看待问题。一般情况下，若是该主键还关联到其他的外建（比如：学号、身份证号）时，我们以此（学号、身份证号）做主键，因为主键默认情况下是聚焦索引，这样我们在进行业务查询时执行效率就会好一些。并且自增主键的数据规律非常明显，这样别人就可以轻易地采集到我们的数据。

**字段类型规范**

在分析业务需要以后使用尽量少的空间来存储数据，例如：能使用 int 就不要使用 varchar、char，能用 varchar(16) 就不要使用 varchar(256)，利用我们经常需要存储的端口、IP 地址等信息完全可以使用 int 类型来存储。固定的长度最好使用 char 类型存储，每一个字段都要一个默认值而不是直接使用 null 类型，这样会预备大量的空间也是一种资源浪费，能使用 tinyint 就不要使用 smallint、int。当然以上提到的节省空间的基础是必须满足我们的业务需求。

**索引规范**

一般索引的数量不要太多，索引可以提高我们对数据的查询速度，但是过多无用的索引也会影响我们对数据库的写入操作，所以索引并不是一定就能优化我们的执行效率，我们需要根据业务需求来斟酌使用。

一般情况下，我们对索引使用从命名上（例如我们这里对 user_id 添加索引，命名应该为 user_id_index）、从使用频率上，比如我们对字段 user_name 的使用率比较高，经常需要用它来做 SQL 语句的条件判断，我们也可以对其使用索引（user_name_index）来提高执行效率。

想必大家还想知道复合索引是怎么回事，到底该不该使用，比如我们需要执行一条 SQL 语句，这个 SQL 语句包含多个查询条件（user_id = 0132, user_name = ‘林中’, user_age = 29），我们可以对这三个字段 建一个复合索引，这样的话针对这条 SQL 的执行查询效率就会提高很多。切记不要过多用索引，否则对表更新的效率有很大的影响，因为我们在更新表的时候数据库也要花大量的时间去更新索引（也就是执行写入操作）。

复合索引举例：

```
CREATE INDEX columnId ON table1(col1,col2,col3) ；  # 创建复合索引
select * from table1 where col1= A and col2= B and col3 = C； # 条件查询
```

**数据库范式**

- 范式一：字段值具有原子性，什么是原子性，例如：姓名字段，其中姓和名是一个整体，如果区分姓和名那么必须设立两个独立字段。
- 范式二：每个表必须有主键，满足每条数据的唯一性。
- 范式三：一个表中不能包涵其他相关表中非关键字段的信息，即数据表不能有沉余字段（这个可以根据业务需要来看，因为有时候由于表的关联关系太多，为了便于关联查询，使用冗余字段也有一定的好处）。

#### MySQL 数据库设计原则

在说关于数据库设计的原则之前，我们先来明确一下一个不良版本的数据库设计会对业务带来哪些影响，这样我们在设计数据库时尽量的避免这些问题其实就满足了我们的设计原则。

**数据库设计与业务逻辑不符**

为什么我要把这个放在第一个说，因为在设计数据库之前我们一定要尽可能多地理解业务需求。如果设计不遵循业务要求的话，往往对数据库的结构和后面进行的开发阶段影响是最大的，会让一个淡定的程序员发飙，你们懂得。不仅降低了开发效率、代码质量，还对数据库维护等方面带来极大的不便。

**数据库性能低下**

比如：表之间的关联关系太过复杂、执行一个业务需求的 SQL 往往需要写的相当复杂才能满足客户的要求等。

**扩展性差**

数据库表的设计和业务的关系太过紧凑，比如我们把多个业务场景的数据都放在一个数据表中，在新增加一个需求时我们发现根本没办法实现解耦。

**不利于计算和统计**

比如笔者以前做过一个能源系统，在根据业务需求统计数据量时出现错误，我们进行了分表处理，最后每计算一次业务数据都需要到不同的数据表里面读取数据，这样就大大地降低了业务的执行效率。MySQL 官方给出，在一个表的数据量达到 1000 万左右时会出现数据库服务端层面导致的执行效率低下，所以平时在我们的系统中并不会达到这么多数据，所以分表需要慎重。

**耦合性大**

多张表之间关联得过于紧密，造成一张表发生变化而影响到其他表。

**数据缺失**

由于表之间的关联字段的不合理性，导致数据的缺失。

**数据库设计的重要性**

数据库设计一般占整个项目开发的 40% 的时间，它是整个项目的根基，在设计完成时，我们的项目逻辑在脑海里面已经完成了 80%，所以我们必须重视。

### 三、在全面分析业务场景的前提下进行设计

笔者在这里之所以把业务场景分析单独用一个小节来说明就是因为它的确很重要，做数据库设计就是在满足业务需求的基础上以最优的性能用于业务开发。数据库设计流程可以简单按如下步骤，需求分析—逻辑设计—物理设计—维护优化。

这是一个复杂系统的从产品到架构建模的流程图，大家可以参考：

![img](https://images.gitbook.cn/6c0706d0-cd48-11e9-be2f-a37c59704c17)

（图片引用自：[www.cnblogs.com/sumuncle](https://www.cnblogs.com/sumuncle/p/9507107.html)）

#### 需求分析

作为数据库设计的第一步，需求分析时相当重要的一步。首先，需要分析需要存储哪些数据，然后在看数据的特点、包括数据的时效性等，考虑在项目不断拓展的过程中数据的存储会越来越大的问题改如何处理。数据是否能够清理，不能清理是否需要进行归档记录等问题都需要进行考虑。

如果对于增长比较快，而且数据量又特别大的情况是否需要分表处理，如果是分表，怎样在进行分表的基础上进行设计而不影响业务逻辑的实现效率。以上情况，在进行需求分析的时候确定下来是比较好的。当然在这个阶段能确定下来项目实体是最好不过的，比如我们项目将用到用户、角色两个管理功能。

然后我们这里确定一个用户实体 user 和一个角色实体 role，在接下来的逻辑设计过程中我们在来看用户和角色之间的关系是什么。例如，我们先来定义两个表：

```
CREATE TABLE user
CREATE TABLE role
```

#### 逻辑设计

在进行逻辑设计的时候我们通常需要用到 ER 图的形式：

![在这里插入图片描述](https://images.gitbook.cn/3172e1f0-cd49-11e9-83c0-df5291a24652)

（图片引用自：[blog.csdn.net/moll_77](https://blog.csdn.net/moll_77/article/details/78697672)）

逻辑设计，这一步主要是为了将我们定义的项目实体，通过 ER 图的形式让其关联起来来满足我们的业务需求，如上图所示一个用户对应可以有多个订单，而且一个订单里面又可以包含多个商品。通过 ER 图我们就可以清楚地看出实体之间的关联关系是一对一、一对多、多对多。而这个过程又是离不开我们的需求设计。

以上所言，我们在需求设计中新建个两个数据表 user 和 role，假设他们的关系是多对多，我们就可以通过加一张中间表来实现这种关系。

#### 物理设计

物理设计就是把我们上面确定好的逻辑设计转换为数据库，而在这个过程中我们就需要考虑到数据库方面的具体的技术性问题，比如我们在第二节中提到的设计范式和设计原则。在物理设计阶段时，我们用到一个设计“PowerDesigner”。个人觉得这个工具比较好用，也可自行选择。至于 PowerDesigner 怎么使用大家 Google 一下很多的，也比较简单这里不再赘述。

我们新建一个物理模型：

![在这里插入图片描述](https://images.gitbook.cn/5a69d340-c4aa-11e9-ae56-8befa17c12eb)

如下图，我们可以简单地设计用户和角色的多对多关系如下：

![在这里插入图片描述](https://images.gitbook.cn/eb2a2ea0-c4ac-11e9-ae2f-45ad64e75f26)

### 四、优化数据库对象、结构

在数据库设计的过程中，我们经常会遇到比如：是否所有的设计都应该遵循数据库设计的第三范式，字段的长度的到底定义为多少才算合适等问题。这些问题虽然看起来比较小，但是设计不当就会给我们的系统应用带来很多的问题。本节主要介绍一些常用的数据库对象的优化方法，来解决我们在设计过程中所面临的问题。

**优化表的数据类型**

在 MySQL 数据库中提供了关于表的字段的优化和建议的函数，来让我们方便地得到数据库给出的优化建议。我们再来根据实际应用的情况考虑是否要采用优化建议，使用如下的 SQL 语句：

```
SELECT * FROM tableName PROCEEDURE ANALYSE();
```

我们来进行分步举例说明。

\1. 创建一个数据表

```
CREATE TABLE demo_table(
cust_num MEDIUMINT AUTO_INCREMENT,   -- 编号
cust_name VARCHAR(20) NOT NULL,  --名称
cust_city VARCHAR(10) NOT NULL, --城市
PRIMARY KEY(cust_num),  --主键
);
```

\2. 在创建的数据库表中生成一些测试数据

\3. 使用 PROCEDURE ANALYSE() 函数确定需要优化的列

```
SELECT * FROM demo_table PROCEDURE ANALYSE();
```

\4. 根据应用需求选择需要修复和优化的数据列

```
ALTER TABLE demo_table MODIFY cust_name VARCHAR(10);
```

**拆分数据表提高数据库访问效率**

一般情况下，对于数据库的拆分有两种方式，一种是水平拆分，另外一种则是垂直拆分。所谓水平拆分，根据一列或者多列的值将数据行放到两个独立的数据表中。垂直拆分则是将主码和一些常用的列放到一个表中，再将主码和剩余的列放到另外的一张数据表中。

例如：我们将 2019 年 1 月的淘宝账单存在一张数据表中，再将的数据量存放到另外一张表中。以每个月的时间节点来存放数据，这种方式就是水平分表。当然，这种方式会增加数据查询的复杂性，所以在实际应用中我们需要考虑数据的增长速度再来决定我们的业务是否需要分表处理数据。

**递归范化**

一般情况下，数据库设计需要满足规范化。但是并不是数据库设计的规范程度越高数据库的性能就是越好。因为数据库的设计的规范化越高，那么数据库的表与表之间的关系就越是复杂。所以，我们在设计数据库时就需要考虑使用逆规范化设计数据库来提升数据库的性能。

逆规范化一般使用的技术主要是：增加冗余列、增加派生列、重新组表、分割表。

- 增加冗余列就是在多个表中具有相同的列，这样就可以在开发人员进行 SQL 查询时减少表与表之间的连接操作。
- 增加派生列就是在表中增加的列来自于其他数据表的数据，列的数据由其他表中的数据计算生成，这种操作也是为了减少表与表之间的连接查询，提高查询速度。
- 重新租表则指的是将两个经常使用两个连接查询的数据表组合成一个数据表，当然也是为了减少表的连接查询。
- 至于分割表就是上面提到的表的拆分。

**使用中间表提升统计查询的速度**

加入中间表主要有以下两个优点：

- 一是可以做到与数据原表隔离，在中间表上做数据查询不会影响在线应用。
- 二是可以灵活的增加临时使用的新字段，从而可以提高查询统计的数据效率。

### 五、分析 SQL 的执行效率，从 SQL 层面优化执行效率

#### SQL 语句优化的基本步骤

\1. 使用 show status 命令查看数据库统计参数

```
show status like "com_%"
```

部分结果展示：

```
variable_name（字段名称）   value（值）
com_admin_commands          0
com_alter_db                0
com_alter_event             0
....................................
```

以上我们提到的 SQL 执行结果只是在查询执行操作的次数，比如下面经常遇到的：

```
com_select:  代表执行select的次数
com_insert: 代表执行insert的次数
```

根据上面得到的结果，我们可以很清楚地知道当前的数据库操作主要是以更新还是查询获取数据为主。

\2. 实时查看 SQL 的执行情况，帮助我们定位到问题，SQL 执行情况、线程状态、是否锁表等。

```
show processlist;
```

\3. 查看低效 SQL 的执行计划

通过上一步我们可以定位到执行效率比较低的 SQL 语句，然后我们可以通过指令 EXPLAIN 查看 SQL 在执行过程中的具体信息。

```
EXPLAIN SELECT * FROM demo_table WHERE cust_num = 1
```

然后根据返回的不同维度的结果信息，我们就可以定位到这条 SQL 的问题具体是什么。

\4. 利用 show profile 分析 SQL

如果通过 3 中定位不到 SQL 执行效率的问题，我们可以再使用这一步进行定位 SQL 的问题。MySQL 是从 5.0.37 才增加了对 show profile 的支持。

**第一步：查看 MySQL 是否支持 profile**

```
SELECT @@have_profiling
```

结果为 YES 说明是支持的。

**第二步：打开 profile**

默认情况下，profile 是关闭的，所以我们需要开启一下。

```
mysql> SELECT @@profiling；
mysql> set profiling = 1;
```

**第三步：使用 profile 分析 SQL**

首先，执行一个我们的 SQL：

```
SELECT COUNT(*) FROM demo_table;
```

查看当前 SQL 的 query_id：

```
mysql> show profiles;
```

比如，这里得到的结果 query_id 是 4，我们则可以根据 query_id 查看 SQL 执行过程中的线程的每个状态和消耗时间。

```
mysql> show profile for query 4;
```

通过 show profile 可以定位到 SQL 的执行时间主要都消耗在什么地方。

\5. 分析优化器

MySQL 5.6 提供了对 SQL 的追踪 trace, 更好地理解优化器的行为方式。可以了解到优化器为什么会选择一种方式去进行 SQL 优化，而不是另外的方式。

\6. 利用相应措施进行优化

经过上面的分析，我们在执行全盘扫描时扫描的行数太多，当我们建立索引之后，需要扫描的行数明显减少。可以根据 EXPLAIN 命令再次验证是否优化成功。

#### 索引问题

通常索引是数据库优化最为重要的手段，可以解决大多数 SQL 性能的问题。

**索引的分类**

MySQL 的数据库索引是在存储引擎中实现的，所以每种存储引擎的不一致对应支持的索引也是不一致的。索引主要分为：B-Tree 索引、HASH 索引、R-Tree 索引、Full-Text 索引。其中 B-Tree 索引是最常见的索引，大部分的数据库引擎也都支持这样的索引。

**使用索引**

例如下面 SQL 语句：（[来源](https://blog.csdn.net/yuxiaoshuangshuang/article/details/80597007)）

```
创建普通索引     ALTER TABLE em_ca ADD INDEX INDEX_CA_CONTACT (`CA_CONTACT`);
创建组合索引     ALTER TABLE em_ca ADD INDEX INDEX_CA_CONTACT (`CA_CONTACT`，‘CA_NAME’);
创建唯一索引     create unique index INDEX_CA_ALIAS on em_ca(CA_ALIAS);
创建主键索引     alter table 表名 add primary key(列名)
删除索引         ALTER TABLE admin_credence_info DROP INDEX ACI_PK;
```

查看索引的使用情况，如果返回的结果中 Handler_read_key 的值很大说明索引经常被使用。如果很小说明索引的使用效果并不是很好。我们可以使用如下 SQL 进行查询：

```
mysql> show status like 'Handler_read%';
```

#### 常用 SQL 优化

在前面我们讲解了索引的优化查询，但是在日常的开发中，我们还是会使用一些常用的 SQL，比如 INSERT、GROUP BY 等。类似于这样的 SQL，我们也会给出一些优化的方法。

**INSERT 优化**

常用的方法主要有两种，第一种优化方式使用多个值表的 INSERT 语句，提高效率。

```
INSERT INTO demo_test VALUES(1,2),(1,3),(2,4);
```

第二种方式将索引文件和数据文件放在不同的磁盘上存放（使用建表中的选项）。

**ORDER BY 优化**

- 尽量减少额外的排序，通过索引直接返回有序数据。
- 通过创建合适的索引减少 Filesort 的出现。

**GROUP BY 优化**

在默认数据库设置的情况下，GROUP BY 对所有字段进行排序。所以，我们如果在没有必要对查询结果进行排序的时候，我们可以通过以 GROUP BY NULL 的方式对性能进行提升，如下例子：

```
SELECT * FROM demo_test GROUP BY NULL;
```

**优化子查询**

在进行子查询时，虽然对于多个连表查询时比较方便。但是子查询会创建临时表，利用 JOIN 的方式效率就会比较高。

**优化 OR 查询**

对 OR 的每个条件建立索引。

**SQL 提示**

添加索引提示可以提高效率（可以使得在查询去直接找到我们指定的索引，不用去再找其他的索引），例如：

```
SELECT * FROM demo_test USE INDEX(id_index);  # 使用use index指定索引
```

### 六、从应用层面优化 MySQL 数据库

在实际生产的过程中，数据库服务器的性能毕竟是有限的。所以，我们也需要从应用层面减小数据库的压力。下面笔者将介绍一些常用的优化方法。

**使用连接池**

对于连接池只要开发过 Web 项目应该都知道，所谓连接池其实就类似将所有的连接都放在一个“池子”里面。然后，在我们需要建立连接的时候连接池就会为我们预先准备一个连接，这样一来可以大大的减少创建链接所带来的数据库服务资源的耗费，从而可以从应用层面提高数据库的访问效率。

**减少对数据库的访问**

优化方式一：避免同一数据做数据检索，比如同一张表、同一条件的不同字段等应使用 SQL 一次查询。

优化方式二：使用查询缓存，数据库查询缓存是 4.1 以后新增加的功能。查询缓存是使用不被经常更新的表，因为如果更新频繁缓存里面的数据将会被删除。

查询缓存相关的主要参数：

```
SHOW VARIABLE LIKE '%query_cache%';
```

查看缓存使用情况：

```
SHOW STATUS;
```

**增加 CACHE 层**

增加 CACHE 层可以减轻数据库的负担，但是 CACHE 层有很多的实现方式，所以我们在使用的过程中必须根据实际需求来进行处理。通常情况下，我们可以把部分数据提取出来以文本的方式进行存储，在需要的时候可以对其进行检索。

**数据库服务的均衡**

第一种是在面对大数据、负载量很高的情况，我们通常采用分布式的数据库架构。通过载多台服务器上分布我们的数据来达到负载均衡，目前只有 MySQL 数据库的 InnoDB 引擎是支持分布式的。第二种就是采用主从复制的方式来减少数据库服务的压力。 小结：以上提到的只是一些常用的优化方法，还有很多数据库服务均衡的优化方法需要我们从实践中去总结。

### 七、优化 MySQL Server：从服务端进行数据库优化

#### MySQL 体系架构

MySQL 是由 SQL 接口、解析器、优化器、缓存、存储引擎组成的（SQL Interface、Parser、Optimizer、Caches&Buffers、Pluggable Storage Engines），如下图中说明：

![在这里插入图片描述](https://images.gitbook.cn/2593c3c0-cd41-11e9-b3e5-eb0a42842eb1)

（图片引用自：[www.cnblogs.com/zhoubaojian](https://www.cnblogs.com/zhoubaojian/articles/7866292.html)）

- 应用层：这一层主要是 MySQL 的对外接口，用于各种编程语言来连接数据库操作，主要是 SQL 的交互。
- SQL 层：主要是做用户的权限、管理，SQL 优化器，返回 SQL 查询到的信息结果到应用层。
- 存储层：存储引擎的存在区域，做数据库的存储。

#### 内存优化

由于 MySQL 5.6 版本以后支持的 InnoDB 存储引擎对性能上面有很大的提升，所以接下来的说明都是基于 InnoDB 这个引擎。关于 InnoDB 这里我们也引用一个图片：

![在这里插入图片描述](https://images.gitbook.cn/d16ada80-cd41-11e9-b604-8f8ee8a124cd)

（图片引用自：[blog.csdn.net/weixin_33696106](https://blog.csdn.net/weixin_33696106/article/details/93278547)）

##### **InnoDB 缓存机制及优化**

InnoDB 用一块内存区做 IO 缓存池，该缓存池不仅用来缓存 InnoDB 的索引块，而且用来缓存 InnoDB 的数据库。我们通常通过参数之间的分配比例以及对缓存的刷新活动进行控制来提升缓存机制的性能。

一般情况下需要设置的参数主要是：innodb_buffer_pool_size、old sublist、innodb_old_blocks_time，以及调整缓存池的数量等等。下面举几个常用的例子：

- innodb_buffer_pool_size：它主要是为数据块和索引块都提供数据缓存，在满足内存条件的基础上它的值越大，那么访问 I/O 就会减少从而提高数据库性能。

查看 innodb_buffer_pool_size 的命令：

```
mysqladmin -uroot -p -S /mysql/data/3306/mysql.sock ext|grep -i innodb_buffer_pool
```

- old sublist：old sublist 的比例由系统参数 innodb_old_blocks_pct 决定 取值范围 5~95 默认 37。

```
show global variables like '%innodb_old_blocks%';
```

- innodb_buffer_instances：增大此配置参数可以使缓存池在高并发的情况下可以防止对缓存池资源的争用。

这里附上一张缓存池的体系图供大家参考：

![在这里插入图片描述](https://images.gitbook.cn/15c77900-c7ab-11e9-8c86-935cb15ca973)

（图片引用自：[www.cnblogs.com/zhoubaojian](https://www.cnblogs.com/zhoubaojian/articles/7866292.html)）

其他优化方向：此外，还有关于日志方面的参数优化等。

##### **调整并发相关的参数提高性能**

主要有几个方面：

- 一是调整最大连接数 max_connections，增加应用层的最大连接数减少对并发时候的限制。Windows 平台下（（open tables*2+open connections）<2048），Linux 平台下（linux 平台下 支持 500~1000）。
- 二是 table_open_cache 的调整，一般情况下如果 opened_tables 的参数值值比较大，说明这个参数的值设置的比较小。
- 三是 thread_cache_size 的设置，为加快连接数据库速度 MySQL 缓存一定数量的客户服务线程备用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。
- 四是 innodb_lock_wait_timeout 设置，控制事务等待行锁时间 默认 50ms 可以根据需要动态设置，对于需要快速反馈的交互式 OLTP 应用，可以将行锁等待超时时间调小，避免事务长时间挂起；对于后台批处理，可以将行锁等待时间调大，避免发生大的回滚操作。

参考内容：

> https://blog.csdn.net/ichglauben/article/details/81269126

#### MySQL 文件结构

MySQL 数据库文件结果主要有如下几种。

\1. 错误日志文件，查看命令：

```
show vaariables like "log_error";
```

\2. 二进制日志文件，查看命令：

```
show vaariables like "datadir";
```

\3. 慢查询日志，查看命令：

```
show vaariables like "%long%";
```

\4. Genaral 日志：启动 general log 和慢日志类似，需要同时设置两个参数：general_log=ON 开启 general 日志；general_log_file=/path to/general.log 设置 general 日志的文件路径。

\5. Pid 文件：MySQL 实例的进程 ID 文件。

\6. Socket 文件：当用 Unix 套接字方式进行连接时需要的文件。

\7. MySQL 表结构文件：.frm 后缀命名的文件都是表结构文件，和存储引擎类型无关。所有的表都会生成一个 .frm 文件。

### 八、总结

本文中关于 MySQL 的数据库设计及优化希望给大家提供一个设计及优化注意的方向，关于数据库优化我们在结合实际应用的时候要考虑的方面很多，主要看我们在面对实际项目的过程中如何抉择。有讲得不合理的地方还望大家指出，感谢阅读。