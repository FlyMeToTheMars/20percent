# 剑指Java

## TOC

[TOC]

## 计算机网络核心

### OSI网络分层

![](https://gitee.com/jinxin.70/oss/raw/master/uPic/5e6fa15f0841966011201587_2020_05_07_10_59_11.jpg)



![](https://gitee.com/jinxin.70/oss/raw/master/uPic/aYa9u4_2020_05_07_11_04_47.png)

### TCP/IP分层

**TCP/IP是OSI标准的实现**

| OSI七层模型 | TCP/IP概念层模型 | 功能                                   | TCP/IP协议族                     |
| ----------- | ---------------- | -------------------------------------- | -------------------------------- |
| 应用层      |                  | 文本传输、电子邮件、文件服务、虚拟终端 | FTP，HTTP，SMTP，DNS，Telnet     |
| 表示层      | 应用层           | 数据格式化，代码转换，数据加密         |                                  |
| 会话层      |                  | 解除或建立与别的断点的联系             |                                  |
| 传输层      | 传输层           | 提供端对端的接口                       | TCP，UDP                         |
| 网络层      | 网络层           | 为数据包选择路由                       | IP，ICMP，RIP，OSPF，BCP         |
| 数据链路层  |                  | 传输有地址的帧以及错误监测功能         | SLIP，CSLIP，PPP，ARR，RARP，MTU |
| 物理层      | 链路层           | 以二进制的数据形式在物理媒体上传输数据 | ISO2110，IEEE802，IEEE802.2      |



![image-20200507133108407](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200507133108407_2020_05_07_13_31_09.png)

### 小结

了解OSI网络分层，有哪些层

对分层协议处理数据有基本的认知，数据如何被一层层处理，封包拆包

了解TCP/IP分层，知道基本的IP、TCP、HTTP属于TCP/IP的哪一层

## TCP的三次握手

### 传输控制协议TCP简介

- 面向连接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用校验和来校验数据在传输过程中是否有误



### [套接字](https://zh.wikipedia.org/wiki/Berkeley套接字)：端对端通信

两个进程在计算机内部进行通信，可以通过管道、内存共享、信号量、消息队列等方法。

两个进程需要通信，最基础的都需要有唯一的标志，能够找到对方，本地进程通信时可以使用PID。

不同计算机中的两个线程通信，需要通过协议、IP、端口来唯一表示一个进程。

网络层的IP协议可以唯一标示主机，而传输层的协议和端口可以唯一标示主机中的一个进程。

协议，IP，端口，这其实已成为一个标准，称为[套接字Socket](https://blog.csdn.net/wangluqinglxq/article/details/38402759)，类Unix系统都提供了Socket接口，用于不同机器间的进程进行网络通信的时候，提供通信端点。Socket一般成对出现，客户端Socket和服务端Scoket。

### TCP头部

![img](https://img.mukewang.com/szimg/5d600c94087d466708000564.jpg)

### TCP三次握手

握手是为了建立连接

![image-20200507154755543](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200507154755543_2020_05_07_15_47_56.png)



SYN

SYN，ACK

ACK

### 为什么需要三次握手才能建立起连接

为了初始化Sequence Number的初始值

服务端根据Sequence Number开始处理数据，如果第二次握手后，客户端没有传ACK确认，没有带seq，服务端不知道从什么位置处理数据。

### SYN FLood攻击，首次握手的隐患-SYN超时

客户端发送SYN报文后，客户端挂了，服务端收到SYN报文会发送SYN+ACK报文给客户端，由于客户端挂了，服务端无法接受到ACK确认，服务端会不断重试（再次发送SYN+ACK给客户端），直到超时才断开连接。

黑客利用这点进行SYN FLood攻击

#### 如何防护SYN FLood攻击？

- 缩短SYN Timeout时间

- 设置SYN Cookie

**注意：**可是上述的两种方法只能对付比较原始的SYN Flood攻击，缩短SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie更依赖于对方使用真实的IP地址，如果攻击者以数万/秒的速度发送SYN报文，同时利用SOCK_RAW随机改写IP报文中的源地址，以上的方法将毫无用武之地。

更高级的攻击和防御姿势参考[这篇文章](https://blog.csdn.net/XavierDarkness/article/details/78123506)

通常服务器都不是直接对外暴露的，前面还有网关或者反向代理服务器Nginx等。所以了解一下这些服务器如何预防常见的攻击比较有用。

#### Nginx预防常见攻击

[nginx预防常见攻击](https://www.cnblogs.com/jojoword/p/10766352.html)



### 建立连接后，Client出现故障怎么办

保活机制

- 向对方发送保活探测报文，如果未收到相应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接



## TCP的四次挥手

挥手是为了终止连接

![image-20200507191449178](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200507191449178_2020_05_07_19_14_49.png)

客户端发送FIN报文

服务端收到后发送ACK报文

服务端在将最后的数据传送完后发送FIN报文给客户端

客户端收到发送ACK报文给服务端，客户端等待状态，经过一段时间才释放连接

### 为什么会有TIME_WAIT状态

- 确保有足够的时间让对方收到ACK

- 避免新旧连接混淆

### 为什么需要四次握手才能断开

因为TCP是全双工的，发送方和接收方都需要FIN报文和ACK报文

### 服务器出现大量CLOSE_WAIT原因

表现：客户端一直请求，但是返回给客户端的数据是异常的。

对方关闭socket连接，我方忙于读或写，没有及时关闭连接

- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置



获取服务器处于各个状态的连接数

```shell
netstat -n | awk '/^tcp/{++S[$NF]}END{for(a in S) print a,S[a]}'
```

![image-20200507193944375](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200507193944375_2020_05_07_19_39_44.png)

如果``CLOSE_WAIT``有几千就需要排查问题，Linux为每个用户分配有限的文件句柄数，连接和文件句柄数一一对应，如果``CLOSE_WAIT``太多，说明占用了很多连接通道。一旦达到上限，新的请求就无法处理，系统就会出现大量``too many open files``异常。可能会造成软件崩溃。

## TCP和UDP区别

### UDP简介

### UDP报文结构

![image-20200507195855905](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200507195855905_2020_05_07_19_58_56.png)

### UDP的特点

- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有8个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维护复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或合并

### 总结

TCP面向连接，UDP无连接，适合消息多播发布

可靠性，TCP可靠，握手确认重传保证

有序性，TCP利用序列号保证有序性

速度，TCP需要做很多额外的事情，稍慢

量级，TCP重量级，报文头20个字节



## TCP的滑动窗口

### RTT和RTO

RTT：发送一个数据包到收到对应的ACK，所花费的时间

RTO：重传时间间隔

### TCP使用滑动窗口做流量控制与乱序重排

- 保证TCP的可靠性
- 保证TCP的流控特性

### 窗口数据的计算过程

![image-20200507230751054](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200507230751054.png)

### TCP会话的发送方



![image-20200507231115631](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200507231115631.png)

2，3为发送窗口

### TCP的接收方

![image-20200507231000828](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200507231000828.png)

### 总结

TCP的传输可靠性来源于确认重传机制

发送窗口只有收到接收端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界

接收窗口只有在前面所有的段都确认的情况下，才会移动左边界，当前面还有字节为接收，收到后面的字节的时候，窗口是不会移动的，并不对后续字节确认，以此确保对端会对这些数据重传。

应用可以通过控制本端窗口的大小，控制对端的发送窗口进行流量限制。

## HTTP相关